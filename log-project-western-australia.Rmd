---
title: "log-project-western-australia"
output: github_document
date: '2022-05-23'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Research Motivation
Understanding how spatial variation is linked to diversity maintenance in natural communities is a pillar of plant community ecology. Theoretically, a variable landscape can maintain diversity via niche partitioning: different species can trade off in performing better or worse depending on the conditions of the patch they are growing in, and as a result, more species can sustainably coexist in a community than if it were spatially heterogeneous. In the hyperdiverse system of native annual plants in Western Australia, fallen logs may be one of the greatest contributors to generating spatial variation that could help maintain species diversity. Considerable anecdotal evidence suggests that fallen logs generate spatial variation, or patchiness, in the environment (Figure 1), and that species or assemblages of plants may respond differently depending on if they are near logs or not. Despite such anecdotal evidence, it is yet unknown if and how fallen logs contribute to maintaining species diversity in the native annual plant communities of the Western Australian wheat belt. 

<center>
![Figure 1: image of annual plant halos around logs](example_winter.JPG){width=50%}
</center>
The project will address the following questions: 

**1) Are/how are plant communities in fallen log patches different from patches that are in the open?**

**2) Why are plant communities in fallen log patches different from patches in the open?** 

**3) Are plant species performances affected by proximity to fallen logs? ** 

### Hypotheses
The null hypothesis, H0, is that annual plants in fallen log patches are not different in diversity, abundance, or composition from open patches. 

In addition to the null hypothesis, the following constitute four, non-mutually exclusive hypotheses concerning how fallen logs may introduce spatial variation in the environment. I include corresponding predictions for how plant communities may differ between fallen log patches as compared to open patches.
<br><br>
**H1: Log decomposition creates islands of fertility directly around the fallen log.** <br>
Prediction 1: Nutrient composition around logs will be higher than in open plots <br>

Prediction 2: Variation in nutrient composition in log vs open environments will correspond to variation in species composition, abundance, and/or richness in these environments. <br>

Prediction 3: All sown plants will perform best in environments where organic logs have been left 'insitu'.  In locations where logs have been removed or replaced with pvc, the legacy of the nutrient island effect will yield higher sown plant performance than when compared to locations where logs have never been. The effect of the nutrient island in locations where logs have been added to open environments should yeild higher plant performance over time. *note: performance is measured in terms of germination rate, survival to fruiting, fecundity, and/or biomass.* <br><br>

**H2: Fallen logs alter the microclimate directly around them by providing shade.**<br> Prediction 1: Shade and temperature around logs vs in open plots will be different <br>

Prediction 2: Variation in shade and temperature in log vs open environments will correspond to variation in species composition, abundance, and/or richness in these environments. <br>

Prediction 3: All sown plants will perform best in environments where there are organic or pvc logs, no matter if they have been recently moved or not.<br><br>

**H3: Fallen logs trap dispersing seeds as they are blown along the ground.**<br>

Prediction 1: Dispersing seeds accumulate around logs, leading to a denser stand of plants in fallen log patches. Plant abundance in fallen log patches will be higher as compared to open patches. Rare plants will be more common in fallen log patches as compared to open patches <br>

Prediction 2: All sown plants will perform the same in all experimental environments <br><br>

**H4: At least some species perform differently according to variation in log vs. open environments and have short dispersal kernals, causing fitness-density covariance** <br><br>
<center>
![Figure 2: Photo before germination, after a rain. Notice the seeming wet halo under and around the branch](wetpatch_example2.jpg){width=50%}
</center>

### Experimental Design
In this experiment, 224 plots are arranged in 7 blocks of 32 plots each within the Caron Dam nature reserve. [A map can be found here](https://www.google.com/maps/d/edit?mid=1z6w6tScsCcKSpsdUmoupfOJVaaq16VYk&usp=sharing). <br>*note: the location info for 3.02 is probably incorrect as of May 2022, and location info is currently unavailable for plots 6.25 and 7.19* 

Each block is approximately 30m X 30m in area. Plots are 1m long and linear, and have a pin tag on either end (see Figure 3). The pin tags have the identity of the plot written on them in the form of "blocknumber.plotnumber". Plots are 1m or more away from each other. 

In each block, plot environments can be one of six types:<br>
-	A 1m log that is out in the open (open_with_log,  4 plots)  <br>
-	A 1m log that is a part of a tree (insitu_log, 4 plots)<br>
-	A 1m pvc pipe that is out in the open (open_with_pvc, 4 plots)<br>
-	A 1m pvc pipe that is a part of a tree (insitu_pvc, 4 plots)<br>
-	A plot that is out in the open (open, 8 plots) <br>
-	A gap in a log where a log used to be (gap, 8 plots)<br>

In half of the plots (not including open plots),the addition, exchange, or removal of logs or pvc to the environment was implemented in October 2020, before seed dispersal. In the other half of these plots, these manipulations were implemented after seed dispersal, in March 2021. 

Within each 1m long plot, there is a ~20cm long microtransect. The ends of the microtransects are marked by a nail and a washer sunken into the ground. Each microtransect is approximately 21 cm in internal length from inner washer edge to inner washer edge. Microtransects are not sided. 

In half of all plots, seeds were sown in March 2021 and February 2022. In these plots, 15 seeds each of Trachymene ornata (TROR), Goodenia rosea (GORO), and Trachymene cyanopetala (TRCY) are sown outside of the microtransects as in the corresponding diagram. These plants were selected because they represent plants common to communities next to logs (TROR), out in the open (GORO), or both (TRCY). The plots where seeds were sown are called 'lambda' plots as noted in Figure 3. 

<center>
![Figure 3: plot schematic](plottypes2021.png){width=50%}
</center>

### Datasets 
There are two sets of data that I have collected since the project began. 

(1) Community data, before and after the experiment was implemented. Every year during peak biomass we surveyed plant communities at every centimeter along each microtransect. Plant count and identity information is collected at each centimeter. These data are available from 2020 (before the experiment began) and 2021 (one year into the experiment).

(2) Performance data of TROR, TRCY, and TROR. In 2021, the only performance data that were collected after sowing the experiment were the total number of plants that came up and survived to fruiting for each species in each location, as well as their total biomass. This was because of logistical issues due to covid. In 2022, no performance data has been collected yet. I am planning on collecting germination rate, survival over the season, and fecundity. 


### Preliminary analysis

##### 1) Are/how are plant communities in fallen log patches different from patches that are in the open? <br>

The ways I have looked at this so far are to compare the initial composition of annual plant communities in log vs. open plots before we implemented the experiment. I am suppressing the display of most of the data wrangling code in the output in the following stuff, but if you'd like to see you can take a look at what's in the .Rmd file.

**Abundance** <br>
First, I look at the abundance of microtransect plants in log vs open plots in 2020.  For this analysis, I include all plants including unknown plants. I find that log transects have marginally significantly more plants than open transects, but it really is a marginal difference (mean difference is approximately a half a plant). 

```{r abundance code, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE}

#### packages #### 
require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)


#### wrangling ####  
comm<-read.csv("species_composition_data.csv", header=T)

# remove the locations surveyed in 2021 that were not surveyed in 2020 - aka, cm=0 and cm=21
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6)], 1, paste, collapse=":")

# need to make each row a community using matrify
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(commtry$x=="x")]<-1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
ncol(commtry) # how many species are we working with in our community matrix

# store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
names(commtry)

# split group info into columns for each variable
mat<-separate(commtry, 81, c("time","block","transect","init"), ":")
names(mat) #check

# add groupname using time, block, init columns
mat$grp<-apply(mat[c(81:84)], 1, paste, collapse=":")
names(mat) #check

# another df where the grouping variables are time, block, transect and initial state
# each row is a transect in a certain year.
df<-mat[,c(1:80,85)]
df2 = df %>% mutate(across(.cols=1:80,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames


#################### this is specific to abundance analysis ###########

# sum observations across initial X transect X time X  block (group variable)
# this gives number of plants in each row observation
blocksum<-rowsum(df2[,c(1:80)], group=df2$grp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames

## add in group vars 
nublock<-separate(blocksum, 81, c("time","block","transect","init"), ":")
nublock$total<-rowSums(nublock[,c(1:79)])
nublock$presence<-ifelse(nublock$total > 0,  1, 0)

# only before treatments installed
dat<-nublock[which(nublock$time=="t0"),]
```

```{r message=FALSE, warning=FALSE, paged.print=FALSE, results='markup'}
# look at plant abundance in log vs open 

# look at range of data - what family should i use? 
range(dat$total)

## using poisson. including random effects throws is.Singular error: see ?is.Singular for details
abun.mod<-glm(total~init, data=dat, family='poisson') 
summary(abun.mod)

# the difference between open and log environments is marginal, where log has marginally significantly more plants. it's not a lot though. The model-estimated difference is like half a plant. 
emmeans(abun.mod, ~init, type='response')

# here's a quick and dirty plot of model estimated means and CIs for abundance in each kind of plot.
emmip(abun.mod, ~init, type='response', CI=T)+theme_bw()+labs(x="Initial condition", y="Number of plants")

# can also look at presence absence but it's really only a few zeros - no significant difference here.
abun.mod2<-glm(presence~init, data=dat, family='binomial')
summary(abun.mod2)

```

**Diversity**<br>
Next, I look at the diversity of microtransect plants in log vs open plots in 2020. For the below analysis, I take a conservative approach and only include known species, because most of the unknown species were a result of not being able to differentiate between known species. Diversity is Shannon's diversity index and estimated by pooling the species in each treatment type in each block (N=14). Shannon's diversity is not different between the two environments.  

```{r diversity code, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE}

#### wrangling ####  
comm<-read.csv("species_composition_data_no_unk.csv", header=T)

# remove the locations surveyed in 2021 that were not surveyed in 2020 - aka, cm=0 and cm=21
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6)], 1, paste, collapse=":")

# need to make each row a community using matrify
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(commtry$x=="x")]<-1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
ncol(commtry) # how many species are we working with in our community matrix

# store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
names(commtry)

# split group info into columns for each variable
mat<-separate(commtry, 66, c("time","block","transect","init"), ":")
names(mat) #check

#################### this is specific to species diversity analysis ###########

# make numeric
numat = mat %>% mutate(across(.cols=1:65,.fns=as.numeric)) # make everything numeric

# sum species for each group (grouped by init, block, time)
nudat<-numat%>% 
  group_by(init, block, time) %>% summarise(across(where(is.numeric), sum))

# make a data frame
dat<-as.data.frame(nudat)
dat1<-dat[which(dat$time=="t0"),]

#estimate diversity for each row/group. don't include 'x' 

# no groups, just estimate diversity of each row
est<-dat1[,c(4:66)]
dat1$diversity<-diversity(est, index='shannon') 
```

```{r message=FALSE, warning=FALSE, results='markup'}
# what does our data look like? 
hist(dat1$diversity) # pretty normal!

## model, this time I can add a random effect for block. diversity in this case is shannon's diversity of each transect 
div.mod<-lmer(diversity~init+(1|block), data=dat1)

# summary 
summary(div.mod)

# plot of difference - not significant. 
emmip(div.mod, ~init, CI=T)+theme_bw()+labs(x="Initial condition", y="Shannon Diversity")
```

Just for kicks, I can also look at species rarefaction curves, which tell me how quickly species accumulate in my surveys. I chose to make curves for all initial treatment X block combinations (14 curves). 

```{r rarefaction code,  message=F, echo=F}

#### rarefaction
summed_blks<-numat%>% 
  group_by(init, block) %>% summarise(across(where(is.numeric), sum))

matdat<-as.data.frame(summed_blks[,c(3:66)])
grp<-as.data.frame(summed_blks[,1:2])
grp$block_cols<-c(rep(rainbow(7),2))
grp$init_lty<-c(rep(1,7), rep(2,7))
nsp<-specnumber(matdat)
raremax<-min(rowSums(matdat))
raredat<-rarefy(matdat, raremax)
rarecurve(matdat, step=1, sample=raremax, col=grp$block_cols, lty=grp$init_lty, lwd=2, bty='n')
legend(50, 10, legend=c("log", "open"), lty=c(1:2), lwd=2)
```

**Dissimilarity** <br>
Finally, I can look at how communities are different in the two different initial treatments - i.e. how different open vs log locations were before we initiated the experiment. For this analysis, I do not include unknown species. I do include cases where there are no individuals in the community. 

In the following analysis, I use nonmetric multidimensional scaling, variance partitioning, redundancy analysis, and partial redundancy analysis to understand the relative contributions of the initial treatment (log or open) and block (1-7) to overall community composition. First, I look at how well initial treatment and block jointly describe variation in community composition using an rda analysis.  
```{r dissimilarity wrangling code, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE}

# add groupname using time, block, init columns
mat$grp<-apply(mat[c(66:69)], 1, paste, collapse=":")
names(mat) #check

# another df where the grouping variables are time, block, transect and initial state
# each row is a transect in a certain year.
df<-mat[,c(1:65,70)]
df2 = df %>% mutate(across(.cols=1:65,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 66, c("time","block","transect", "init"), ":")

# want to sum across transects in same block X init X time treatment
nublock$sumgrp<-apply(mat[c(66,67,69)], 1, paste, collapse=":")
head(nublock)

# sum observations across initial X time X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 2 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:65)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
nrow(blocksum) # it is 28 rows as expected

##  expand again
blocksum<-separate(blocksum, 66, c("time","block", "init"), ":")

# count info - just look at assemblies at initial timepoint.
# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t0<-blocksum[which(blocksum$time=="t0"),c(1:65)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init[which(blocksum$time=='t0')]
group_block<-blocksum$block[which(blocksum$time=='t0')]

# MDS 
ass.rel.t0<-decostand(assemblies_t0, method='hel') #standardize assemblies 
ass.rel.t0_NMS<-metaMDS(ass.rel.t0, distance='bray', k=5) # run MDS 
stressplot(ass.rel.t0_NMS) # check fit

# scores
mds_scores<-as.data.frame(scores(ass.rel.t0_NMS)$sites) # extract scores
mds_scores$site<-rownames(scores(ass.rel.t0_NMS)$sites) # extract names 
mds_scores$treatment<-group_init # grouping factor 1 
mds_scores$block<-group_block # grouping factor 2 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

```

```{r message=FALSE, warning=FALSE, results='markup'}
#### rda model analysis & results #### 
# can look at significance of model where initial treatment and block explain variation in community
trt_tot<-rda(ass.rel.t0~init+block) # run model using standardized data 
anova.cca(trt_tot) ## test for model significance
```
As you can tell, the overall model of initial treatment+block significantly explains variation in the data. 

I can then look at how initial treatment and block separately describe variation in community composition using variance partitioning analyses, and test the significance of the contribution of initial treatment in explaining variation. 

```{r message=FALSE, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE}
# can model using varpart to look at contributions of initial treatment and block
var.mod<-varpart(ass.rel.t0, init,block) # run model on standardized data
showvarparts(2, bg = c("hotpink","skyblue"))

```
As shown in the varpart venn diagram, the variance partitioning analysis indicates that the initial treatment only contributes about 8% explained variation in the full model. We can test if the contribution of initial treatment is significant using partial redundancy analysis. see `?rda` for details.

```{r message=FALSE, warning=FALSE, echo=FALSE, results='markup'}
plot(var.mod, bg=c("hotpink","skyblue"))
mtext("X1=Initial treatment; X2=Block", side=3)
## can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
trt_Frac<-rda(ass.rel.t0, init, block) # partial rda model
anova.cca(trt_Frac) ## this tells us if first condition, init, significantly contributes to overall variance explanation. 
```
Despite only explaining about 8% of variation, the contribution of initial treatment (open / log) is marginally significant (p-value sits around 0.05). Log communities and open communities are therefore marginally significantly different from each other in their overall composition. 

Let's visualize the differences in the communities using an ordination plot: 
```{r dissimilarity wrangling code part 2, echo=FALSE, warning=FALSE}
### extracting species scores and plotting 
# species scores
species.scores<-as.data.frame(scores(ass.rel.t0_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores[mds_scores$treatment == "log", ][chull(mds_scores[mds_scores$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores[mds_scores$treatment == "open", ][chull(mds_scores[mds_scores$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)
 
ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray')+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")
  
```
</center>
In this plot, the points represent blocks, and the colors represent log vs open initial treatment. Species are represented by a four letter species code and their position is not jittered. If there is a line attached to a species code, the other end of the line indicates where the actual location is in the ordination. 

Two things to note here: there were 22 species that didn't have loadings in the nmds, perhaps because they were too rare (*note: still need to look into this*). In this initial analysis, we can see that TROR falls out as a 'log' species, GORO as an 'open' species, and TRCY sits where the two groups overlap, so our intuition about these species was correct. 

##### 2) Why are plant communities in fallen log patches different from patches in the open? 
This can be answered by comparing community abundance, diversity, and dissimilarity among experimental treatments in 2021 and beyond. It can also be corroborated by looking at environmental correlates to the changes we observe among treatments as time goes on. I'm not quite sure how to do this at the moment.

##### 3) How is plant species performance affected by proximity to fallen logs? 
This can be answered by comparing performance of sown plants among experimental treatments in 2021 and beyond.
