---
title: "log-project-aubrie-winnie"
output:
  html_document: default
  pdf_document: default
date: "2024-02-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Understanding how spatial variation is linked to diversity maintenance in natural communities is a pillar of plant community ecology. Theoretically, a variable landscape can maintain diversity via niche partitioning: different species can trade off in performing better or worse depending on the conditions of the patch they are growing in, and as a result, more species can sustainably coexist in a community than if it were spatially homogeneous. In the hyperdiverse system of native annual plants in Western Australia, fallen logs may be one of the greatest contributors to generating spatial variation that could help maintain species diversity. Considerable anecdotal evidence suggests that fallen logs generate spatial variation, or patchiness, in the environment (Figure 1), and that species or assemblages of plants may respond differently depending on if they are near logs or not. Despite such anecdotal evidence, it is yet unknown if and how fallen logs contribute to maintaining species diversity in the native annual plant communities of the Western Australian wheat belt. 

<center>
![Figure 1: image of annual plant halos around logs](example_winter.JPG){width=50%}
</center>
The project will address the following questions: 

**Q1) Are/how are plant communities in fallen log patches different from patches that are in the open?**

**Q2) Why are plant communities in fallen log patches different from patches in the open?** 

**Q3) Are/how are plant species performances affected by proximity to fallen logs?** 

### Hypotheses
The null hypothesis, H0, is that annual plants in fallen log patches are not different in diversity, abundance, or composition from open patches. 

In addition to the null hypothesis, the following constitute four, non-mutually exclusive hypotheses concerning how fallen logs may introduce spatial variation in the environment. I include corresponding predictions for how plant communities may differ between fallen log patches as compared to open patches.
<br><br>
**H1: Log decomposition creates islands of fertility directly around the fallen log.** <br>
Prediction 1: Nutrient composition around logs will be higher than in open plots <br>

Prediction 2: Variations in nutrient composition in log vs open environments will correspond to variations in species composition, abundance, and/or richness in these environments. <br>

Prediction 3: All sown plants will perform best in environments where organic logs have been left 'insitu'.  In locations where logs have been removed or replaced with pvc, the legacy of the nutrient island effect will yield higher sown plant performance than when compared to locations where logs have never been. The effect of the nutrient island in locations where logs have been added to open environments should yeild higher plant performance over time. *note: performance is measured in terms of germination rate, survival to fruiting, fecundity, and/or biomass.* <br><br>

**H2: Fallen logs alter the microclimate directly around them by providing shade.**<br> Prediction 1: Shade and temperature around logs vs in open plots will be different <br>

Prediction 2: Variation in shade and temperature in log vs open environments will correspond to variation in species composition, abundance, and/or richness in these environments. <br>

Prediction 3: All sown plants will perform best in environments where there are organic or pvc logs, no matter if they have been recently moved or not.<br><br>

**H3: Fallen logs trap dispersing seeds as they are blown along the ground.**<br>

Prediction 1: Dispersing seeds accumulate around logs, leading to a denser stand of plants in fallen log patches. Plant abundance in fallen log patches will be higher as compared to open patches. Rare plants will be more common in fallen log patches as compared to open patches <br>

Prediction 2: All sown plants will perform the same in all experimental environments <br><br>

**H4: At least some species perform differently according to variation in log vs. open environments and have short dispersal kernels, causing fitness-density covariance** <br><br>
<center>
![Figure 2: Photo before germination, after a rain. Notice the seeming wet halo under and around the branch](wetpatch_example2.jpg){width=50%}
</center><br>

### Experimental Design
In this experiment, 224 plots are arranged in 7 blocks of 32 plots each within the Caron Dam nature reserve. [A map can be found here](https://www.google.com/maps/d/edit?mid=1z6w6tScsCcKSpsdUmoupfOJVaaq16VYk&usp=sharing). <br>*note: the location info for 3.02 is probably incorrect as of May 2022, and location info is currently unavailable for plots 6.25 and 7.19* 

Each block is approximately 30m X 30m in area. Plots are 1m long and linear, and have a pin tag on either end (see Figure 3). The pin tags have the identity of the plot written on them in the form of "blocknumber.plotnumber". Plots are 1m or more away from each other. 

In each block, plot environments can be one of six types:<br>
-	A 1m log that is out in the open (open_with_log,  4 plots)  <br>
-	A 1m log that is a part of a tree (insitu_log, 4 plots)<br>
-	A 1m pvc pipe that is out in the open (open_with_pvc, 4 plots)<br>
-	A 1m pvc pipe that is a part of a tree (insitu_pvc, 4 plots)<br>
-	A plot that is out in the open (open, 8 plots) <br>
-	A gap in a log where a log used to be (gap, 8 plots)<br>

In half of the plots (not including open plots), the addition, exchange, or removal of logs or pvc to the environment was implemented in October 2020, before seed dispersal. In the other half of these plots, these manipulations were implemented after seed dispersal, in March 2021. 

Within each 1m long plot, there is a ~20cm long microtransect. The ends of the microtransects are marked by a nail and a washer sunken into the ground. Each microtransect is approximately 21 cm in internal length from inner washer edge to inner washer edge. Microtransects are not sided. 

In half of all plots, seeds were sown in March 2021 and February 2022. In these plots, 15 seeds each of Trachymene ornata (TROR), Goodenia rosea (GORO), and Trachymene cyanopetala (TRCY) are sown outside of the microtransects as in the diagram. These plants were selected because they represent plants common to communities next to logs (TROR), out in the open (GORO), or both (TRCY). The plots where seeds were sown are called 'lambda' plots as noted in Figure 3. In the dataset, the rows with a "1" in the 'seeding_trt' column are the plots that had seeds sown into them.

<center>
![Figure 3: plot schematic](plottypes2021.png){width=50%}
</center>

### Datasets 
The sets of data that we have collected for this arm of the project are the following. 

(1) Community data, before and after the experiment was implemented. <br> 
- Every year during peak biomass we surveyed plant communities at every centimeter along each microtransect. Plant count and identity information is collected at each centimeter. 
- These data are available from 2020 (before the experiment began), 2021 (one year into the experiment), and 2022 (two years into the experiment)

(2) Soil nutrient analysis in the open and insitu log plots.<br>
- In 2022, we sampled 14 soil samples taken from one insitu_open plot and one insitu_log plot from each of the seven blocks. At each plot, three 5-cm deep soil cores from random positions were collected with the use of a Hamilton tree planter. Particularly in insitu_log plots, soil cores were removed within a five-centimeter zone adjacent to the coarse wood debris. Between each extraction, all tools were sterilised with 80% ethanol to prevent cross contamination. Soil cores from each plot were then mixed, cooled and immediately transported to a commercial laboratory (CSBP laboratories). Nutrient analysis was conducted at CSBP laboratories to determine soil pH, organic C, P, K, inorganic nitrogen (NO3- and NO4+) and basic exchangeable cations (Ca, Mg, Na and K). All basic exchangeable cations were summed together and labelled as "CEC".

(3) Performance data of TROR, TRCY, and TROR. <br>
- In 2021, the only performance data that were collected after sowing the experiment were the **total number of plants that came up and survived to fruiting for each species in each location, their total biomass, and their per capita biomass**. I calculated per capita biomass by dividing total biomass of the collected focal plants by the number of focal plants observed. This was because of logistical issues due to covid. In this dataset, there were two instances where the number of plants collected was greater than the number of seeds sown. Both instances were T. cyanopetala, where nplants = 16 and 18. For these two datapoints I chose to convert the count values to 15, assuming that every individual we planted came up, and that the extra were either naturally occurring seeds or that the number of seeds that we put into the ground was greater than 15 (human error). To calculate total biomass for these two instances, I divided the total biomass by the number of individuals observed, and multiplied by 15. <br>

- In 2022, we went to the field early in the season and counted and thinned the number of germinated seedlings in each location. We therefore have a count for germination, but for the following reasons there are some issues with these data. The first is that we probably surveyed germination a little too early. The seedlings were often super small or hadn't come up yet. Because we couldn't come back later to re-thin the plots, we went ahead with counting and thinning seedlings. The values in the dataset for 2022 (nplants_data_2022.csv) corresponding to this germination survey are "ntrcy_germ", "ngoro_germ" and "ntror_germ". The second is that at the end of the growing season, Jake and Winnie came back and found that there was often more than one plant of the focal species where we seeded them, and sometimes there was one or more focal plants that popped up where we had not observed germination earlier in the season. We assume that these plants come from the seeds we planted, and that they came up later than our initial germination survey. The number of plants observed and collected at each location at the end of the season are in the columns "nplants_tror", "nplants_goro" and "nplants_trcy" in the nplants_data_2022.csv data file. Because ngerm and nplants don't totally capture what came up where we sowed seed, I chose to analyze the total number of observed plants. I calculated this as the number of total plants we observed between the germination and the end of the season, being careful not to double-count the individual that was left after thinning from the first round of germination survey. The performance data I analyze here are **total number of plants that came up for each species in each location, and the per capita biomass of plants collected at the end of the season**. 

## Methods and analysis

### **Q1 Are/how are plant communities in fallen log patches different from patches that are in the open?** <br>
#### *Overview of results* <br> 
Quick recap:

1.    Plant abundance does not differ between log and open plots across all years. 

2.    Plant diversity is higher in log patches in 2022 but no significant difference was detected in 2020 and 2021.

3.    Plot type (log vs open) explains a near-zero portion of the variance in plant species composition across plots across years.

To compare the characteristic of plant communities in fallen log patches and open patches, we assessed differences in plant abundance, diversity using the Shannon diversity index, and plant composition summarized at the transect level. The analysis is organized by year - we analysed the plot-level community data for each year separately: 2020, 2021, and 2022. In other words, each row in the data set represents an individual plot from a specific year. In these analyses, we evaluated three response variables: abundance, diversity, and plant composition.

*2020*

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix.

1.	*Abundance* – No difference in total plant count between log patches and open patches (p = 0.355). Model: total count ~ treatment(log/open) + (1|block).

2.	*Diversity* – Plant diversity (SDI) is marginally lower in open patches than log patches (p = 0.063). Model: diversity ~ treatment(log/open) + (1|block) with zero-inflation terms=~1

3.	*Composition* – Partial rda partitions variance in plant composition by R-squared. As expressed by the constrained term, 'treatment' (p = .001) explains only 1.36% of variations in plant composition. The conditional term 'block' explains 9.17% of variance in plant composition. 89.5% of the variance in plant composition remains unexplained in unconstrained terms. The analysis of variation partitioning uses an adjusted R-squared method to express the variance explained by the explanatory matrix. The variable 'treatment' alone explains about 1% of the total variance, while the 'block' explains roughly 7% of the variance.  Note that the shared fraction in the Venn diagram is not shown as it is negative, likely due to 'treatment' being a suppressor variable with a close-to-zero relationship to plant composition. (Read: https://www.jstor.org/stable/20069271). In a parallel set of analyses, the 4-D NMDS ordination has stress values of 4.8%, suggesting a good fit of ordination. ANOSIM indicates no difference in plant composition between open and log plots (P = 0.5985). 

*2021*

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix.

1.	*Abundance* – No difference between total plant count between log patches and open patches (p = 0.322). Model: total count ~ treatment(log/open) + (1|block).

2.	*Diversity* – No difference in plant diversity (SDI) between open patches and log patches (p = 0.822). Note that the zero-inflated model has a significant constant term. Model: diversity ~ treatment(log/open) + (1|block) with zero-inflation terms=~1

3.	*Composition* – As expressed by the constrained term, 'treatment' (p = .01) explains only 2.15% of variations in plant composition. The conditional term 'block' explains 13.5% of variance in plant composition. 84.4% of the variance in plant composition remains unexplained in unconstrained terms. In terms of adjusted R-squared, the Venn diagram shows that 'treatment' alone explains about 1% and 'block' explains roughly 7% of the total variance in plant composition. Similarly, 'treatment' is likely to be a suppressor. In a parallel set of analyses, the 5-D NMDS ordination has stress values of 4.1%, suggesting a very good fit of ordination. ANOSIM indicates a significant difference in plant composition between open and log plots (P = 0.0088) but the magnitude of difference is rather small (R = 0.28 - ratio of dissimilarity in plant composition between log and open plot types).

*2022*

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix.

1.	*Abundance* – No difference between total plant count between log patches and open patches (p = 0.322). Model: total count ~ treatment(log/open) + (1|block).

2.	*Diversity* – Plant diversity (SDI) is significantly lower in open patches than log patches (p < 0.001). Model: diversity ~ treatment(log/open) + (1|block) with zero-inflation terms=~1

3.	*Composition* – As expressed by the constrained term, 'treatment' (p = 0.002) explains only 3.08% of variations in plant composition. The conditional term 'block' explains 12.7% of variance in plant composition. 84.2% of the variance in plant composition remains unexplained in unconstrained terms. In terms of adjusted R-squared, the Venn diagram shows that 'treatment' alone explains about 2% and 'block' explains roughly 6% of the total variance in plant composition. Similarly, 'treatment' is likely to be a suppressor. In a parallel set of analyses, the 4-D NMDS ordination has stress values of 4%, suggesting a very good fit of ordination. ANOSIM indicates a significant difference in plant composition between open and log plots (P = 0.0017) but the magnitude of difference is rather small (R = 0.31 - ratio of dissimilarity in plant composition between log and open plot types). 

#### *Statistical Methods* <br> 

1.	Abundance comparison 

Comparison of plant abundance between log and open plots involves two types of data: (1) the total plant counts of individual plots of all plots in 2020 before the experiment set up, which includes two initial treatments - "log" and "open"; and (2) the total plant counts from insitu_log and insitu_open plots in 2021 and 2022 respectively. All count data used for abundance comparison includes species with unknown identity. We used a generalized linear mixed-effects model (GLMER) to model the abundance of plant individuals (2020, 2021 and 2022 data) in unaltered fallen log patches and open patches using a Poisson distribution structure with 'block' as a random term. 

2.	Diversity comparison 

 A 20-centimeter linear transect was set up for each plot in 2020. We recorded species identity and individual counts for all species occurring along the transects in 2020, 2021 and 2022 respectively. Comparison of plant diversity between log and open patches involves two types of data: 1. The count of plants for each species in individual plots of all plots in the year 2020, before the experiment setup. The data is differentiated based on the initial treatment of "log" and "open". 2. The count of plants for each species in individual plots from insitu_log and insitu_open plots in the years 2021 and 2022, respectively. All species with unknown identity have been excluded from the data used for diversity comparison. 

The diversity of plants in each community (i.e. plot) was measured by Shannon diversity index (SDI). The distribution of SDI values is zero-inflated as testing with DHARMa. Note that a zero SDI could mean 0 plant in a community or one species without any neighbours. To account for the zero inflation, we used glmmTMB to model the diversity of plant community. We assumed that zeros are generated by different mechanisms in our model and the probability of having an extra zero is uniform for all observations by setting zi=~1. 

3.	Composition 

Comparison of plant composition between log patches and open patches involves two types of data: 1. The count of plants for each species in individual plots of all plots in the year 2020, before the experiment setup. The data is differentiated based on the initial treatment of "log" and "open". 2. The count of plants for each species in individual plots from insitu_log and insitu_open plots in the years 2021 and 2022, respectively. All data used for diversity comparison excludes species with unknown identity. For transects where no plants were found, an artificial species, "x," was added to the species composition matrix to represent zero plants. Data is structured at the plot level with each row representing the composition of plant species in an individual plot. There are 223 plots in 2020, 86 plots in 2021, and 84 plots in 2022, evenly nested in 7 blocks. 

We compared plant species composition between plot treatments (i.e. open vs log) with two separate streams of analyses (1) partial Redundancy Analysis (RDA) + permutation test (ANOVA.acc)+ variation partioning analysis (Venn diagram) and (2) NMDS + ANOSIM (Analysis of Similarities). 

(3.1) We ran a partial Redundancy Analysis (RDA) to test the correlation between species composition (squared-root transformed) and plot treatment (log vs open patch) with 'block' as a conditional term. The effect of plot treatment on plant species composition was adjusted for the covariate 'block'. Significance of model and 'treatment' term were tested with a permutation test (anova.cca function from vegan package). Variation in plant composition explained by plot treatment and block were partitioned and reported in an adjusted R-squared value in a Venn diagram. 

(3.2) Alternatively, we used Non-Metric Dimensional Scaling (NMDS) to analyse the differences in plant communities with Bray-Curtis dissimilarity metrics. For each combination of NMDS axes generated, we plotted a two-dimensional NMDS ordination plot to visualize and interpret the relative position of plant community between plot types and blocks. To better understand the contribution of each species to the compositional changes, we extracted and plotted the ordination scores for each species along each respective NMDS axis. These scores represent the weighted average of a species' abundance score in a sample community along each selected NMDS axes. To further test the degree of similarity in plant species composition between plot treatment types, we used the ANOSIM function, and the resulting R-statistic value depicts the proportion of dissimilarity. 

#### *Analysis*<br>
##### Abundance analysis
** 2020 - 2022 **
```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results='markup', echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# packages

require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)
require(ggpubr)
require(sjPlot)
require(sjmisc)
require(sjlabelled)
require(Matrix)
require(see) #doing this for aubrie because of some weird thing that happened when I installed new version of R 

##### data wrangling #####

# This dataset includes unknown species.
comm <- read.csv("20-22_species_composition_data_w_unk.csv", header=T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable.
mat<-separate(commtry, 107, c("time","block","transect","init", "treatment"), ":")
# names(mat) #check

# Add groupname using time, block, init columns.
# mat$grp1<-apply(mat[c(107:110)], 1, paste, collapse=":")
# mat$grp2<-apply(mat[c(107:111)], 1, paste, collapse=":")
# names(mat) #check

# Another df where the grouping variables are time, block, transect and initial state.
# Each row is a transect in a certain year.
df1 <- mat[which(mat$time=="t0"),]
df1 = df1 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df1)<-NULL # remove rownames
df1$grp1<-apply(df1[c(107:108,110)], 1, paste, collapse=":")

df2 <- mat[which(mat$time=="t1"),]
df2 <- df2[which(df2$treatment=="open" | df2$treatment=="insitu_log"), ]
df2 = df2 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df2)<-NULL # remove rownames
df2$grp1<-apply(df2[c(107:108,110:111)], 1, paste, collapse=":")

df3 <- mat[which(mat$time=="t2"),]
df3 <- df3[which(df3$treatment=="open" | df3$treatment=="insitu_log"), ]
df3 = df3 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df3)<-NULL # remove rownames
df3$grp1<-apply(df3[c(107:108,110:111)], 1, paste, collapse=":")

# df2 = with treatment in the grouping
# df2 = df %>% mutate(across(.cols=1:106,.fns=as.numeric))
# rownames(df2)<-NULL # remove rownames

##### Abundance analysis for 2020 (t0) AND in-situ log and in-situ open plots in 2021 (t1) and 2022 (t2)

# Sum observations across time X block X treatment (group variable).
# This gives number of plants in each row observation (block level).
## blocksum1<-rowsum(df1[,c(1:106)], group=df1$grp1) the original code
grp1 <- df1[, "grp1"]
blocksum1 <- aggregate(df1[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

grp1 <- df2[, "grp1"]
blocksum2 <- aggregate(df2[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

grp1 <- df3[, "grp1"]
blocksum3 <- aggregate(df3[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

# Add in group vars.
nublock1<-separate(blocksum1, 1, c("time","block", "init"), ":")
nublock1$total<-rowSums(nublock1[,c(4:109)])
nublock1$presence<-ifelse(nublock1$total > 0,  1, 0)

nublock2<-separate(blocksum2, 1, c("time","block","init", "treatment"), ":")
nublock2$total<-rowSums(nublock2[,c(5:110)])
nublock2$presence<-ifelse(nublock2$total > 0,  1, 0)
nublock2 <- nublock2[,c(1:3, 5:112)]

nublock3<-separate(blocksum3, 1, c("time","block","init", "treatment"), ":")
nublock3$total<-rowSums(nublock3[,c(5:110)])
nublock3$presence<-ifelse(nublock3$total > 0,  1, 0)
nublock3 <- nublock3[,c(1:3, 5:112)]

# Subset data where before treatments installed (t0), in-situ log and in-situ open from t1 and t2 are included.
# Hence only absolute log effect and absolute open effect are concerned
## dat_t0_insitu<-nublock2[which(nublock2$time=="t0" |  nublock2$treatment=="open" |  nublock2$treatment=="insitu_log"),]

# look at plant abundance in log vs open 
# look at range of data - what family should i use? 
range(nublock1$total)
range(nublock2$total)
range(nublock3$total)

# distribution of data
ggplot(nublock1, aes(sample=total)) + 
  stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock1$total))) + 
  stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock1$total))) # 2020 data fits a poisson dist.

ggplot(nublock2, aes(sample=total)) + 
     stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock2$total))) + 
     stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock2$total))) # neither a normal/poisson distribution fit well 

ggplot(nublock3, aes(sample=total)) + 
     stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock3$total))) + 
     stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock3$total))) # 2022 data fits a poisson dist.

dat_t0_insitu <- rbind(nublock1, nublock2, nublock3)
# since samples from t1 and t2 from are mainly from the same plots as t0. These are not independent replicates and tend to correlated with each other.
# including year and block as random effects
# (1|year) + (1|block) as we think the effect of init on total is the same (slope) but the intercept differ amongst block and year
# but since we have a greater number of sample from t0, data from t0 will contribute more to the variance in abundance.
# see https://bookdown.org/steve_midway/DAR/random-effects.html#pld-example
## abun.mod.t012<- glmer(total~ init + (1|block) + (1|time), data=dat_t0_insitu, family = 'poisson')

# emmeans(abun.mod.t012, ~init, type='response') # plant abundance in log plots is higher by 0.04 plants - which is no higher

# abun.plot <- emmip(abun.mod.t012, ~init, type='response', CI=T)+theme_bw()+labs(x="Initial condition", y="Number of plants")
# print(abun.plot)

##### Reason: why we need to include 'time' as random effect?

# (1) Samples from t1 and t2 from are from the same plots as t0. These are not independent replicates and tend to correlated with each other.
# We included year and block as random effects to alleviate the effect of temporal pseudo-replication.

# summary(aov(total ~ time, data = dat_t0_insitu)) # plant abundance differs between years

# (2) When we stratify the data by year, significance of the difference between log and open treatment is lost.
# if the effect of log-open (slope) is the same across year, year only affecting the intercept.
# since the slopes are similar, we include time as random intercept effect.
abun.mod.t0 <- glm(total ~ init , data = nublock1, family = gaussian)
abun.mod.t1 <- glm(total ~ init , data = nublock2, family = gaussian)
abun.mod.t2 <- glm(total ~ init , data = nublock3, family = gaussian)

# tab_model(abun.mod.t0, abun.mod.t1, abun.mod.t2, file="abundance_comparison.html", dv.labels = c("Abundance:2020", "Abundance:2021", "Abundance:2022"))

# htmltools::includeHTML("abundance_comparison.html")

mimiscols<-c("#D66972","#108780")

em.0 <- as.data.frame(emmeans(abun.mod.t0, ~init, type='response')) %>% mutate(time = "t0") %>% mutate(p = "0.504") %>% mutate(group1="log") %>% mutate(group2="open")
em.1 <- as.data.frame(emmeans(abun.mod.t1, ~init, type='response')) %>% mutate(time = "t1") %>% mutate(p = "0.597") %>% mutate(group1="log") %>% mutate(group2="open")
em.2 <- as.data.frame(emmeans(abun.mod.t2, ~init, type='response')) %>% mutate(time = "t2") %>% mutate(p = "0.712") %>% mutate(group1="log") %>% mutate(group2="open")
abun.mod <- bind_rows(em.0, em.1, em.2) %>%
  mutate(y.position = 15)

abun.emmeans.plot <- ggplot(abun.mod,aes(init, emmean, group=time))+
  scale_color_manual(values=mimiscols)+
  geom_point(aes(col=init), size=4, position=position_dodge(width=0.5))+
  geom_linerange(aes(ymin=lower.CL, ymax=upper.CL, col=init), position=position_dodge(width=0.5))+
 # geom_line(position=position_dodge(width=0.5))+
  facet_wrap(vars(time), labeller = labeller(time = 
    c("t0" = "2020",
      "t1" = "2021",
      "t2" = "2022")))+
  theme_bw()+
  theme(legend.position="top",panel.grid = element_blank())+
  xlab("Plot type")+
  ylab("Abundance")+
  labs(color = "Initial Plot Type") +
  geom_jitter(data=dat_t0_insitu,
             aes(x=init, y=total, color=init), 
             height=0.1,
             alpha=0.5) + stat_pvalue_manual(abun.mod, size = 3.5, linetype = 1)

print(abun.emmeans.plot)
```

##### Diversity analysis
```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results='markup',echo=FALSE}
require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)
require(lmerTest)
require(performance)
require(ggpubr)
require(DHARMa)
require(patchwork)
require(glmmTMB)

# This dataset does not include data where the plant identity is unknown.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify
commsub<-comm[,c(15,10,13)] 

# group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-labdsv::matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1  # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # 42

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block", "transect", "init", "treatment"), ":")
# names(mat) #check

# Add groupname using time, block, init columns
mat$grp<-apply(mat[c(88:92)], 1, paste, collapse=":")
# names(mat) #check

# Another df where the grouping variables are time, block, transect and initial state.
# Each row is a block in a certain year.
numat = mat %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
numat<-numat[which(numat$time=="t0" |  numat$treatment=="open" |  numat$treatment=="insitu_log"),]

# sum species for each group (grouped by init, block, time)
nudat<-numat%>% 
  group_by(time, block, init) %>% summarise(across(where(is.numeric), sum)) #42rows

# make a data frame
dat<-as.data.frame(nudat) # this df contains transect levels from all years

#estimate diversity for each row/group. don't include 'x' 

# no groups, just estimate diversity of each row
est<-dat[,c(4:89)]
dat$diversity<-diversity(est, index='shannon') 

###### We used a hurdle model since the data is zero-inflated
# separate into zero and non-zero observations
# dat$non_zero <- ifelse(dat$diversity > 0, 1, 0)

# what does our data look like? 
# hist(dat$diversity, xlab = "Shannon diversity", main = "Histogram of Shannon diversity index (all years, transect level)") # zero-inflated

# ggplot(dat, aes(x = diversity, fill = as.factor(non_zero))) +
#  geom_histogram(position = "identity", alpha = 1, bins = 30) +
#  labs(x = "Diversity",
#       y = "Frequency") +
#  scale_fill_discrete(name = 'non_zero') +
#  theme_bw()

# shapiro.test((dat$diversity[dat$non_zero == 1])) # non-zero data is not normal

# Non-zero data is, however, an approximate Gaussian distribution
# hist(dat$diversity[dat$non_zero ==1], xlab = "Shannon diversity index (non-zero)", main = "Histogram of Shannon diversity index (non-zero, all years, transect level)") # visually it resembles a lot like a Gaussian distribution 

# Gaussian distribution produced the best-fitting ggplot
# dat_nonzerodat <- dat[dat$non_zero == 1, ]
# ggplot(dat_nonzerodat, aes(sample = diversity)) + 
#                   geom_qq(distribution = qnorm) + 
#                  geom_qq_line(distribution = qnorm) +
#                  ggtitle("normal")

# Hurdle model part 1. Logistic regression to predict the probability of non-zero.
# Plot treatment does determine the probability of non-zero diversity index.
# We included block and time as random terms.
# 0 Shannon diversity index =/= zero plants
# Hurd.mod.1 <- glmer(non_zero ~ init + (1|block) + (1|time), data = dat, family = binomial)
# summary(Hurd.mod.1) # significant

# Open and log environment is significant in explaining the plant diversity in transect levels.
# Lmer was used because the distribution of non-zero data is approximally normal.
# Hurd.mod.2 <- lmer(diversity ~ init + (1|block)+ (1|time), data=subset(dat, non_zero == 1))
# summary(Hurd.mod.2)
# anova(Hurd.mod.2) # lmer on non-zero diversity values is significant

# tab_model(Hurd.mod.1, Hurd.mod.2, dv.labels=c("Prob. SDI>0", "Pron. when SDI>0"), title = "Shannon diversity index (SDI): 2020-2022", file = "sdi_openlog_allyear.html", transform = NULL, show.est = TRUE, show.se = TRUE)
# htmltools::includeHTML("sdi_openlog_allyear.html")

# Check residual
# residuals <- resid(Hurd.mod.2) # Extract residuals
# plot(residuals)
# abline(0,0)
# check_model(Hurd.mod.2)

# zi model using glmmTMB with Gaussian link
# https://journal.r-project.org/archive/2017/RJ-2017-066/RJ-2017-066.pdf
# di.mod.allyear <- glmmTMB(diversity ~ init+(1|block), data=dat, ziformula=~1, family = gaussian)
# summary(di.mod.allyear) # significant! p=0.0132 
# tab_model(di.mod.allyear, dv.labels="SDI [all years]", title = "Shannon diversity index (SDI): 2020-2022")

###### Species diversity analysis for 2020 data (Shannon diversity on transect level) 
# Hurdle model appraoch
# Hurd.mod.1.2020 <- glmer(non_zero ~ init + (1|block), data = dat_2020, family = binomial)
# Hurd.mod.2.2020 <- lm(diversity ~ init, data=subset(dat_2020, non_zero == 1))
## random effect (1|block) removed since it's close to zero
# anova(Hurd.mod.2.2020)

## di.mod.2020 <- glmmTMB(diversity ~ init+(1|block), data=subset(dat, time == "t0"), ziformula=~1, family = gaussian)
# summary(di.mod.2020)
## tab_model(di.mod.2020, dv.labels="SDI [2020]", title = "Shannon diversity index (SDI): 2020")

di.mod.2020 <- glm(diversity ~ init, data=subset(dat, time == "t0"), family = gaussian)
di.mod.2021 <- glm(diversity ~ init, data=subset(dat, time == "t1"), family = gaussian)
di.mod.2022 <- glm(diversity ~ init, data=subset(dat, time == "t2"), family = gaussian)
# Check residual
# residuals <- resid(di.mod.2020) # Extract residuals
# plot(residuals, main="2020")
# abline(0,0)

###### Species diversity analysis for 2021 data (Shannon diversity on transect level)
# Hurdle model appraoch
# Hurd.mod.1.2021 <- glm(non_zero ~ init, data = dat_2021, family = binomial)
# Random effect (1|block) removed since it's close to zero.
# Hurd.mod.2.2021 <- lmer(diversity ~ init + (1|block), data=subset(dat_2021, non_zero == 1))

## di.mod.2021 <- glmmTMB(diversity ~ init+(1|block), data=subset(dat, time == "t1"), ziformula=~1, family = gaussian)
# summary(di.mod.2021)
## tab_model(di.mod.2021, dv.labels="SDI [2021]", title = "Shannon diversity index (SDI): 2021")

# Check residual
# residuals <- resid(di.mod.2021) # Extract residuals
# plot(residuals, main="2021")
# abline(0,0)

###### Species diversity analysis for 2022 data (Shannon diversity on transect level) 
# Hurdle model appraoch
# Hurd.mod.1.2022 <- glmer(non_zero ~ init + (1|block), data = dat_2022, family = binomial, )
# Hurd.mod.2.2022 <- lmer(diversity ~ init + (1|block), data=subset(dat_2022, non_zero == 1))

## di.mod.2022 <- glmmTMB(diversity ~ init+(1|block), data=subset(dat, time == "t2"), ziformula=~1, family = gaussian)
# summary(di.mod.2022)
## tab_model(di.mod.2022, dv.labels="SDI [2022]", title = "Shannon diversity index (SDI): 2022")

# Check residual
# residuals <- resid(Hurd.mod.2) # Extract residuals
# plot(residuals, main="2022")
# abline(0,0)


em.0 <- as.data.frame(emmeans(di.mod.2020, ~init, type='response')) %>% mutate(time = "t0") %>% mutate(p = "p = 0.209")
em.1 <- as.data.frame(emmeans(di.mod.2021, ~init, type='response')) %>% mutate(time = "t1") %>% mutate(p = "p = 0.642")
em.2 <- as.data.frame(emmeans(di.mod.2022, ~init, type='response')) %>% mutate(time = "t2") %>% mutate(p = "p = 0.659")
div.mod <- bind_rows(em.0, em.1, em.2) %>% mutate(group1="log") %>% mutate(group2="open") 

mimiscols<-c("#D66972","#108780")

div.emmeans.plot <- ggplot(div.mod,aes(init, emmean, group=time))+
  scale_color_manual(values=mimiscols)+
  geom_point(aes(col=init), size=4, position=position_dodge(width=0.5))+
  geom_linerange(aes(ymin=lower.CL, ymax=upper.CL, col=init), position=position_dodge(width=0.5))+
  #geom_line(position=position_dodge(width=0.5))+
  facet_wrap(vars(time), labeller = labeller(time = 
    c("t0" = "2020",
      "t1" = "2021",
      "t2" = "2022")))+
  theme_bw()+
  xlab("Plot type")+
  ylab("Shannon diversity index")+
  labs(color = "Initial Plot Type")+
  theme_bw()+
  theme(legend.position="top",panel.grid = element_blank())+
  xlab("Plot type")+
  ylab("Diversity")+
  labs(color = "Initial Plot Type")+
  geom_jitter(data=dat,
             aes(x=init, y=diversity, color=init), 
             height=0.1,
             alpha=0.5) + stat_pvalue_manual(div.mod, size = 3.5, linetype = 1, y.position = 2.8)

print(div.emmeans.plot)
```

##### Composition analysis
```{r, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results='markup', fig.width =8, fig.height=8, echo=FALSE}
# Run this chunk before running any year specific chunk below packages
library(tidyverse)
require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)
require(lmerTest)
require(performance)
require(ggpubr)
require(patchwork)

# Data wrangling
# This dataset does not include data where the plant identity is unknown.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# Make a group name for each row
comm <- comm[which(comm$year =="t0" | comm$treatment_type=="open" | comm$treatment_type=="insitu_log"),]
comm$grp<-apply(comm[c(1,3,6)], 1, paste, collapse=":") # timepoint, block, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 70, c("time","block","init"), ":")
names(mat) #check
```

Composition dissimilarity *2020*

```{r, message=TRUE, warning=TRUE, include=TRUE, paged.print=FALSE, results='markup',echo=FALSE}
# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t0"),]
mat2$grp<-apply(mat2[c(71,72)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:69, 73)]
df2 = df %>% mutate(across(.cols=1:69,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 70, c("block", "init"), ":") # just looking at time, block & initial treatment

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t0<-nublock[,c(1:69)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-nublock$init
group_block<-nublock$block

# MDS 
ass.rel.t0<-decostand(assemblies_t0, method='hel') #standardize assemblies 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

# Redundancy analysis
# can test for significance of contribution of the fraction of initial treatment
# can look at significance of model where initial treatment and block explain variation in community
trt_Frac<-rda(ass.rel.t0~init+block) # run model using standardized data 
summary(trt_Frac)
anova.cca(trt_Frac, step=1000, by="term") ## test for model significance
anova.cca(trt_Frac)
RsquareAdj(trt_Frac) #explanatory power

result.df.t0 <- data.frame(
  stringsAsFactors = FALSE,
  Partitioning_of_variance = c("rda(formula = ass.rel.t0 ~ init + block) ", "Total", "Constrained", "Unconstrained"),
  Inertia  = c(" ", 0.5901, 0.3817, 0.2084),
  Proportion = c("", 1.0000, 0.6469,0.3531),
  Note = c(" ", "adj.r.squared = 0.2349251", "Variance explained by 'treatment' + 'block", "Unexplained variance"),
  Permutation_test = c("Model signif. = 0.006 **", "Treatment", "Block", "Residual"),
  Df = c(" ", 1,6, 6),
  Variance = c(" ", 0.05094, 0.33078,0.20837),
  F = c(" ", 1.4670, 1.5875, " "),
  P = c(" ", "0.099", "0.010 **", "")
  )
knitr::kable(result.df.t0, "simple")

# Using varpart to look at contributions of initial treatment and block
var.mod.t0 <-varpart(ass.rel.t0, init, block) # run model on standardized data

plot(var.mod.t0, bg=c("hotpink","skyblue"),
     Xnames = c("Treatment", "Block"))

var.mod.t0$part # varpart shows adj. rsquared

# Plotting rda
perc <- round(100*(summary(trt_Frac)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_Frac, display="bp", choices=c(1, 2), scaling=1)
sc_bp <- as.data.frame(sc_bp)
sc_bp <- sc_bp[1,1:2]
sc_sp <-vegan::scores(trt_Frac, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_Frac, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_Frac)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_Frac,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-1,1), 
     ylim = c(-.4,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 

text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

block_levels <- as.numeric(factor(sc_si$block))
sc_si$treatment <- as.factor(sc_si$treatment)
points(sc_si, 
       col = ifelse(sc_si$treatment == "log", "#63A088", "#56638A"), 
       pch = block_levels, # Adding 1 to shift block levels to start from 1
       cex = 0.8)
ordihull(sc_si[,1:2], groups = sc_si$treatment, show.group = sc_si$treatment,
         col =c("#63A088", "#56638A"),
         draw = 'polygon')

legend("topright", 
       legend = c("log", "open"), 
       col = c("#63A088", "#56638A"),
       title = "Treatment",
       pch = 20,  # Don't include point shapes
       cex = 0.8,
       box.lty=0)

# Create legend for point shape
legend("right",
       legend = unique(sc_si$block),
       pch = unique(block_levels),
       title = "Block",
       col = "black",  # Black color for legend text
       pt.cex = 1.5,
       cex = 0.8,
       box.lty=0,
      xjust = 1.3)

# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] +0.08, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2], 
     labels = "open", 
     col = "black", 
     cex = 1, 
     font = 2)


```


```{r 2020 NMDS, message=TRUE, warning=TRUE, include=TRUE, paged.print=FALSE, results='markup',echo=FALSE}
# MDS 
ass.rel.t0_NMS <- metaMDS(ass.rel.t0, distance = 'bray', k = 2, trace = FALSE) # run MDS 
stressplot(ass.rel.t0_NMS) # check fit
ano_t0 <- anosim(assemblies_t0, mat2$init, distance = "bray", permutations = 9999)
print(ano_t0) # marginally different

# scores
mds_scores_t0<-as.data.frame(vegan::scores(ass.rel.t0_NMS)$sites) # extract scores
mds_scores_t0$site<-rownames(vegan::scores(ass.rel.t0_NMS)$sites) # extract names 
mds_scores_t0$treatment<-group_init # grouping factor 1 
mds_scores_t0$block<-group_block # grouping factor 2 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

# Extracting species scores and plotting 
# Species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t0_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t0[mds_scores_t0$treatment == "log", ][chull(mds_scores_t0[mds_scores_t0$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t0[mds_scores_t0$treatment == "open", ][chull(mds_scores_t0[mds_scores_t0$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

nmds.plot<- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t0, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment") +
  labs(title=paste0("Stress: ", round(ass.rel.t0_NMS$stress,3)))

print(nmds.plot)

# Plotting all combination of NMDS axes when k > 2
# treatments <- unique(mds_scores_t0$treatment)
# plots <- list()
# num_axes <- 4  

#  for (i in 1:num_axes) {
#  for (j in (i+1):num_axes) {  
#    if (j <= num_axes && i != j) {  
#      log <- mds_scores_t0[mds_scores_t0$treatment == "log", ]
#      open <- mds_scores_t0[mds_scores_t0$treatment == "open", ]
      
#      log_hull <- log[chull(log[[paste0("NMDS", i)]], log[[paste0("NMDS", j)]]), ]
#      open_hull <- open[chull(open[[paste0("NMDS", i)]], open[[paste0("NMDS", j)]]), ]
      
#      hulldat <- rbind(log_hull, open_hull)
      
#      plot_name <- paste0(i, "+", j)
      
#      plots[[plot_name]] <- ggplot() +
#        theme_bw() +
#        theme(panel.background = element_blank(),
#              panel.grid.major = element_blank(),
#              panel.grid.minor = element_blank(),
#              plot.background = element_blank(),
#              axis.text = element_text(size = 15),
#              axis.title = element_text(size = 15),
#              legend.title = element_text(size = 15),
#              legend.text = element_text(size = 10)) +
#        geom_text_repel(data = species.scores, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), label = species), alpha = 0.9, size = 3, col = 'darkgray', na.rm = TRUE) +
#        geom_polygon(data = hulldat, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), fill = treatment, group = treatment), alpha = 0.3) + scale_fill_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        geom_point(data = mds_scores_t0, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), shape = block, col = treatment), size = 6) + scale_shape_manual(values = c(14, 15, 16, 17, 11, 18, 8), name = 'Block') +
#        scale_colour_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        xlab(paste0("NMDS", i)) +
#        ylab(paste0("NMDS", j))
#    }
#  }
#}

#((plots$`1+2` + plots$`1+3`)/(plots$`1+4` + plots$`2+3`)/(plots$`2+4` + plots$`3+4`)) + plot_layout(guides ="collect") + plot_annotation(paste0("[2020] Stress:",round(ass.rel.t0_NMS$stress,3), " (k = 4)"))


```

Composition dissimilarity *2021*

```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE,echo=FALSE}
# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t1"),]
mat2$grp<-apply(mat2[c(71,72)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:69, 73)]
df2 = df %>% mutate(across(.cols=1:69,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 70, c("block", "init"), ":") # just looking at time, block & initial treatment

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t1<-nublock[,c(1:69)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-nublock$init
group_block<-nublock$block

# MDS 
ass.rel.t1<-decostand(assemblies_t1, method='hel') #standardize assemblies 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

# redundancy analysis
trt_Frac<-rda(ass.rel.t1~init+block) # run model using standardized data 
summary(trt_Frac)
anova.cca(trt_Frac, step=1000, by="term") ## test for model significance
anova.cca(trt_Frac)
RsquareAdj(trt_Frac)$adj.r.squared #explanatory power

result.df.t1 <- data.frame(
  stringsAsFactors = FALSE,
  Partitioning_of_variance = c("rda(formula = ass.rel.t1 ~ init + block)", "Total", "Constrained", "Unconstrained"),
  Inertia  = c(" ", 0.5326, 0.3506, 0.1821),
  Proportion = c("",1.0000, 0.6582, 0.3418),
  Note = c(" ", "adj.r.squared = 0.2593985", "Variance explained by 'treatment' + 'block", "Unexplained variance"),
  Permutation_test = c("Model signif. = 0.001 ***", "Treatment", "Block", "Residual"),
  Df = c(" ", 1,6,6),
  Variance = c(" ", 0.064359, 0.286205,0.182059),
  F = c(" ", 2.121, 1.572, " "),
  P = c(" ", "0.007 **", "0.002 **", " ")
  )
knitr::kable(result.df.t1, "simple")

# can model using varpart to look at contributions of initial treatment and block
var.mod.t1<-varpart(ass.rel.t1, init, block) # run model on standardized data
plot(var.mod.t1, bg=c("hotpink","skyblue"),
     Xnames = c("Treatment", "Block"))

var.mod.t1$part

# Plotting rda
perc <- round(100*(summary(trt_Frac)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_Frac, display="bp", choices=c(1, 2), scaling=1)
sc_bp <- as.data.frame(sc_bp)
sc_bp <- sc_bp[1,1:2]
sc_sp <-vegan::scores(trt_Frac, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_Frac, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_Frac)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_Frac,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-1,1), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 

text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

block_levels <- as.numeric(factor(sc_si$block))
sc_si$treatment <- as.factor(sc_si$treatment)
points(sc_si, 
       col = ifelse(sc_si$treatment == "log", "#63A088", "#56638A"), 
       pch = block_levels, # Adding 1 to shift block levels to start from 1
       cex = 0.8)
ordihull(sc_si[,1:2], groups = sc_si$treatment, show.group = sc_si$treatment,
         col =c("#63A088", "#56638A"),
         draw = 'polygon')

legend("topright", 
       legend = c("log", "open"), 
       col = c("#63A088", "#56638A"),
       title = "Treatment",
       pch = 20,  # Don't include point shapes
       cex = 0.8,
       box.lty=0)

# Create legend for point shape
legend("right",
       legend = unique(sc_si$block),
       pch = unique(block_levels),
       title = "Block",
       col = "black",  # Black color for legend text
       pt.cex = 1.5,
       cex = 0.8,
       box.lty=0,
      xjust = 0.8)

# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] -0.08, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] +0.01, 
     labels = "open", 
     col = "black", 
     cex = 1, 
     font = 2)
```

```{r 2021 NMDS, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE,echo=FALSE}
# MDS 
# ass.rel.t1<-decostand(assemblies_t1, method='hel') #standardize assemblies 
ass.rel.t1_NMS <- metaMDS(ass.rel.t1, distance = 'bray', k = 2, trace = FALSE) # run MDS 
# stressplot(ass.rel.t1_NMS) # check fit
ano_t1 <- anosim(assemblies_t1, mat2$init, distance = "bray", permutations = 9999)
print(ano_t1)

# scores
mds_scores_t1<-as.data.frame(vegan::scores(ass.rel.t1_NMS)$sites) # extract scores
mds_scores_t1$site<-rownames(vegan::scores(ass.rel.t1_NMS)$sites) # extract names 
mds_scores_t1$treatment<-group_init # grouping factor 1 
mds_scores_t1$block<-group_block # grouping factor 2 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

### extracting species scores and plotting 
# species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t1_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t1[mds_scores_t1$treatment == "log", ][chull(mds_scores_t1[mds_scores_t1$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t1[mds_scores_t1$treatment == "open", ][chull(mds_scores_t1[mds_scores_t1$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)
 
nmds.plot <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t1, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment") +
  labs(title=paste0("Stress: ", round(ass.rel.t1_NMS$stress,3)))

print(nmds.plot)

# Plotting all combination of NMDS axes when k > 2
# treatments <- unique(mds_scores_t1$treatment)
#plots <- list()
#num_axes <- 5  

#for (i in 1:num_axes) {
#  for (j in (i+1):num_axes) {  
#    if (j <= num_axes && i != j) {  
#      log <- mds_scores_t1[mds_scores_t1$treatment == "log", ]
#      open <- mds_scores_t1[mds_scores_t1$treatment == "open", ]
      
#      log_hull <- log[chull(log[[paste0("NMDS", i)]], log[[paste0("NMDS", j)]]), ]
#      open_hull <- open[chull(open[[paste0("NMDS", i)]], open[[paste0("NMDS", j)]]), ]
      
#      hulldat <- rbind(log_hull, open_hull)
      
#      plot_name <- paste0(i, "+", j)
      
#      plots[[plot_name]] <- ggplot() +
#        theme_bw() +
#        theme(panel.background = element_blank(),
#              panel.grid.major = element_blank(),
#              panel.grid.minor = element_blank(),
#              plot.background = element_blank(),
#              axis.text = element_text(size = 15),
#              axis.title = element_text(size = 15),
#              legend.title = element_text(size = 15),
#              legend.text = element_text(size = 10)) +
#        geom_text_repel(data = species.scores, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), label = species), alpha = 0.9, size = 3, col = 'darkgray', na.rm = TRUE) +
#        geom_polygon(data = hulldat, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), fill = treatment, group = treatment), alpha = 0.3) + scale_fill_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        geom_point(data = mds_scores_t1, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), shape = block, col = treatment), size = 6) + scale_shape_manual(values = c(14, 15, 16, 17, 11, 18, 8), name = 'Block') +
#        scale_colour_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        xlab(paste0("NMDS", i)) +
#        ylab(paste0("NMDS", j))
#    }
#  }
#}

#(plots$`1+2`+ plots$`1+3`)/ (plots$`1+4`+ plots$`1+5`)/(plots$`2+3` + plots$`2+4`)/ (plots$`2+5`+ plots$`3+4`)/ (plots$`3+5`+ plots$`4+5`) + plot_layout(guides ="collect") + plot_annotation(paste0("[2021] Stress:",round(ass.rel.t1_NMS$stress,3), " (k = 5)"))
```

Composition dissimilarity *2022*

```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE,echo=FALSE}
# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t2"),]
mat2$grp<-apply(mat2[c(71,72)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:69, 73)]
df2 = df %>% mutate(across(.cols=1:69,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 70, c("block", "init"), ":") # just looking at time, block & initial treatment

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t2<-nublock[,c(1:69)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-nublock$init
group_block<-nublock$block

# MDS 
ass.rel.t2<-decostand(assemblies_t2, method='hel') #standardize assemblies 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

# redundancy analysis
trt_Frac<-rda(ass.rel.t2~init+ block) # run model using standardized data 
summary(trt_Frac)
anova.cca(trt_Frac, step=1000, by="term") ## test for model significance
anova.cca(trt_Frac)
RsquareAdj(trt_Frac)$adj.r.squared #explanatory power

result.df.t2 <- data.frame(
  stringsAsFactors = FALSE,
  Partitioning_of_variance = c("rda(formula = ass.rel.t2 ~ init + block)", "Total", "Constrained", "Unconstrained"),
  Inertia  = c(" ", 0.5340, 0.3581, 0.1759),
  Proportion = c("",1.0000, 0.6705, 0.3295),
  Note = c(" ", "adj.r.squared = 0.2861857", "Variance explained by 'treatment + block'", "Unexplained variance"),
  Permutation_test = c("Model signif. = 0.002 **", "Treatment", "Block", "Residual"),
  Df = c(" ", 1,6,6),
  Variance = c(" ", 0.06081, 0.29726,0.17593),
  F = c(" ", 2.0739, 1.6897, " "),
  P = c(" ", "0.017 *", "0.003 **", " ")
  )
knitr::kable(result.df.t2, "simple")

# can model using varpart to look at contributions of initial treatment and block
var.mod.t2<-varpart(ass.rel.t2, init, block) # run model on standardized data
plot(var.mod.t2, bg=c("hotpink","skyblue"),
     Xnames = c("Treatment", "Block"))

# Plotting rda
perc <- round(100*(summary(trt_Frac)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_Frac, display="bp", choices=c(1, 2), scaling=1)
sc_bp <- as.data.frame(sc_bp)
sc_bp <- sc_bp[1,1:2]
sc_sp <-vegan::scores(trt_Frac, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_Frac, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_Frac)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_Frac,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.5,.5), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 

text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

block_levels <- as.numeric(factor(sc_si$block))
sc_si$treatment <- as.factor(sc_si$treatment)
points(sc_si, 
       col = ifelse(sc_si$treatment == "log", "#63A088", "#56638A"), 
       pch = block_levels, # Adding 1 to shift block levels to start from 1
       cex = 0.8)
ordihull(sc_si[,1:2], groups = sc_si$treatment, show.group = sc_si$treatment,
         col =c("#63A088", "#56638A"),
         draw = 'polygon')

legend("topright", 
       legend = c("log", "open"), 
       col = c("#63A088", "#56638A"),
       title = "Treatment",
       pch = 20,  # Don't include point shapes
       cex = 0.8,
       box.lty=0)

# Create legend for point shape
legend("right",
       legend = unique(sc_si$block),
       pch = unique(block_levels),
       title = "Block",
       col = "black",  # Black color for legend text
       pt.cex = 1.5,
       cex = 0.8,
       box.lty=0,
      xjust = 0)

# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] -0.08, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] + 0.02, 
     labels = "open", 
     col = "black", 
     cex = 1, 
     font = 2)

```


```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE,echo=FALSE}
# MDS 
# ass.rel.t2<-decostand(assemblies_t2, method='hel') #standardize assemblies 
ass.rel.t2_NMS <- metaMDS(ass.rel.t2, distance = 'bray', k = 2, trace=FALSE) # run MDS 
stressplot(ass.rel.t2_NMS) # check fit
ano_t2 <- anosim(assemblies_t2, mat2$init, distance = "bray", permutations = 9999)
print(ano_t2)

# scores
mds_scores_t2<-as.data.frame(vegan::scores(ass.rel.t2_NMS)$sites) # extract scores
mds_scores_t2$site<-rownames(vegan::scores(ass.rel.t2_NMS)$sites) # extract names 
mds_scores_t2$treatment<-group_init # grouping factor 1 
mds_scores_t2$block<-group_block # grouping factor 2 

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-nublock$init
group_block<-nublock$block

### extracting species scores and plotting 
# species scores
species.scores.t2<-as.data.frame(vegan::scores(ass.rel.t2_NMS,"species")) ## some species don't have scores
species.scores.t2$species<-rownames(species.scores.t2) 

### NMDS 1 and 2 
log<-mds_scores_t2[mds_scores_t2$treatment == "log", ][chull(mds_scores_t2[mds_scores_t2$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t2[mds_scores_t2$treatment == "open", ][chull(mds_scores_t2[mds_scores_t2$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)
 
nmds.plot <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores.t2, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t2, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment") +
  labs(title=paste0("Stress: ", round(ass.rel.t2_NMS$stress,3)))
  
print(nmds.plot)


# Plotting all combination of NMDS axes when k > 2
# treatments <- unique(mds_scores_t2$treatment)
# plots <- list()
# num_axes <- 4  

#for (i in 1:num_axes) {
#  for (j in (i+1):num_axes) {  
#    if (j <= num_axes && i != j) {  
#      log <- mds_scores_t2[mds_scores_t2$treatment == "log", ]
#      open <- mds_scores_t2[mds_scores_t2$treatment == "open", ]
#      
#      log_hull <- log[chull(log[[paste0("NMDS", i)]], log[[paste0("NMDS", j)]]), ]
#      open_hull <- open[chull(open[[paste0("NMDS", i)]], open[[paste0("NMDS", j)]]), ]
#      
#      hulldat <- rbind(log_hull, open_hull)
#      
#      plot_name <- paste0(i, "+", j)
#      
#      plots[[plot_name]] <- ggplot() +
#       theme_bw() +
#        theme(panel.background = element_blank(),
#              panel.grid.major = element_blank(),
#              panel.grid.minor = element_blank(),
#              plot.background = element_blank(),
#              axis.text = element_text(size = 15),
#              axis.title = element_text(size = 15),
#              legend.title = element_text(size = 15),
#              legend.text = element_text(size = 10)) +
#        geom_text_repel(data = species.scores.t2, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), 
#                                                      label = species), alpha = 0.9, size = 3, col = 'darkgray', na.rm = TRUE) +
#        geom_polygon(data = hulldat, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), fill = treatment, group = #treatment), alpha = 0.3) +
#        scale_fill_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        geom_point(data = mds_scores_t2, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), shape = block, col = treatment), size = 6) + 
#        scale_shape_manual(values = c(14, 15, 16, 17, 11, 18, 8), name = 'Block') +
#        scale_colour_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        xlab(paste0("NMDS", i)) +
#        ylab(paste0("NMDS", j))
#    }
# }
#}

#((plots$`1+2` + plots$`1+3`)/(plots$`1+4` + plots$`2+3`)/(plots$`2+4` + plots$`3+4`)) + plot_layout(guides ="collect") + plot_annotation(paste0("[2022] Stress:",round(ass.rel.t2_NMS$stress,3), " (k = 4)"))

```

Composition dissimilarity *2020 - 2022*
```{r, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE,echo=FALSE}
# Composition dissimilarity * 2020 - 2022 *
# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat3 <- mat
mat3$grp<-apply(mat3[c(70,71,72)], 1, paste, collapse=":") # block, init as grouping
# names(mat3) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat3[,c(1:69, 73)]
df2 = df %>% mutate(across(.cols=1:69,.fns=as.numeric)) # make everything numeric
# rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 70, c("time", "block", "init"), ":") # just looking at time, block & initial treatment

# want to sum across transects in same block X init treatment
nublock$sumgrp<-apply(nublock[c(70:72)], 1, paste, collapse=":")
# head(nublock)

# sum observations across initial X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 3 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:69)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
nrow(blocksum) # it is 42 rows as expected 

##  expand again
blocksum<-separate(blocksum, 70, c("time", "block", "init"), ":")

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t012<-blocksum[,c(1:69)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init
group_block<-blocksum$block
group_time<-blocksum$time

# MDS 
ass.rel.t012<-decostand(assemblies_t012, method='hel') #standardize assemblies 
ass.rel.t012_NMS <- metaMDS(ass.rel.t012, distance = 'bray', k = 2, trace=FALSE) # run MDS 
# stressplot(ass.rel.t012_NMS) # check fit
ano_t012 <- anosim(assemblies_t012, blocksum$init, distance = "bray", strata=blocksum$time, permutations = 9999)
print(ano_t012)

# scores
mds_scores_t012<-as.data.frame(vegan::scores(ass.rel.t012_NMS)$sites) # extract scores
mds_scores_t012$site<-rownames(vegan::scores(ass.rel.t012_NMS)$sites) # extract names 
mds_scores_t012$treatment<-group_init # grouping factor 1 
mds_scores_t012$block<-group_block # grouping factor 2 
mds_scores_t012$time<-group_time # grouping factor 3

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor
time<-as.factor(group_time)

# can model using varpart to look at contributions of initial treatment and block
var.mod2<-varpart(ass.rel.t012, init, block, time) # run model on standardized data
plot(var.mod2, bg=c("hotpink","skyblue","lightyellow"),
     Xnames = c("Treatment", "Block", "Year"))

## can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
trt_Frac<-rda(ass.rel.t012~ init +block + Condition(time)) # partial rda model
summary(trt_Frac) 
RsquareAdj(trt_Frac)$adj.r.squared #explanatory power
anova.cca(trt_Frac, by='terms') ## this tells us if first condition, init, significantly contributes to overall variance explanation. 
anova.cca(trt_Frac)

result.df.t012 <- data.frame(
  stringsAsFactors = FALSE,
  Partitioning_of_variance = c("rda(formula = ass.rel.t012 ~ init + block + Condition(time)) ", "Total", "Conditioned", "Constrained", "Unconstrained"),
  Inertia = c("", 0.61523, 0.08993, 0.20243, 0.32287),
  Proportion = c("",1.0000, 0.1462, 0.3290, 0.5248),
  Note = c(" ", "adj.r.squared = 0.2252166", "Variance explained by 'year'", "Variance explained by 'treatment' and 'block'", "Unexplained variance"),
  Permutation_test = c("Model signif. = 0.001 ***", "Treatment", "Block", "Residual", " "),
  Df = c(" ",  1,6,32, " "),
  Variance = c(" ", 0.03848, 0.16395,0.32287, " "),
  F = c(" ", 3.8134, 2.7083, " "," "),
  P = c(" ", "0.001 ***", "0.001 ***", " "," ")
  )
knitr::kable(result.df.t012, "simple")

# Plotting rda
perc <- round(100*(summary(trt_Frac)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_Frac, display="bp", choices=c(1, 2), scaling=1)
sc_bp <- as.data.frame(sc_bp)
sc_bp <- sc_bp[1,1:2]
sc_sp <-vegan::scores(trt_Frac, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_Frac, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_Frac)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_Frac,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.8,.8), 
     ylim = c(-.6,.6),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 

text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

block_levels <- as.numeric(factor(sc_si$block))
sc_si$treatment <- as.factor(sc_si$treatment)
points(sc_si, 
       col = ifelse(sc_si$treatment == "log", "#63A088", "#56638A"), 
       pch = block_levels, # Adding 1 to shift block levels to start from 1
       cex = 0.8)
ordihull(sc_si[,1:2], groups = sc_si$treatment, show.group = sc_si$treatment,
         col =c("#63A088", "#56638A"),
         draw = 'polygon')

legend(x = 0.8,
       y = 0.3,
       legend = c("log", "open"), 
       col = c("#63A088", "#56638A"),
       title = "Treatment",
       pch = 20,  # Don't include point shapes
       cex = 0.8,
       box.lty=0,
       xjust = 0.5,
      yjust = 0.5)

# Create legend for point shape
legend(x = 0.8,
       y = -0.2,
       legend = unique(sc_si$block),
       pch = unique(block_levels),
       title = "Block",
       col = "black",  # Black color for legend text
       pt.cex = 1.5,
       cex = 0.8,
       box.lty=0,
      xjust = 0.5,
      yjust = 0.5)

# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] -0.08, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] -0.01, 
     labels = "open", 
     col = "black", 
     cex = 1, 
     font = 2)

### extracting species scores and plotting 
# time
time_arrows <- data.frame(
  x = c(-0.87417680, 1), # X-coordinates of the arrow (start and end points)
  y = c(0, 1), # Y-coordinates of the arrow (start and end points)
  time = c("Time 1", "Time 2") # Time labels for the arrows
)

# species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t012_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t012[mds_scores_t012$treatment == "log", ][chull(mds_scores_t012[mds_scores_t012$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t012[mds_scores_t012$treatment == "open", ][chull(mds_scores_t012[mds_scores_t012$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

year2020 <- mds_scores_t012[mds_scores_t012$time == "t0", ][chull(mds_scores_t012[mds_scores_t012$time == 
                                                          "t0", c("NMDS1", "NMDS2")]), ]
year2021<- mds_scores_t012[mds_scores_t012$time == "t1", ][chull(mds_scores_t012[mds_scores_t012$time == 
                                                          "t1", c("NMDS1", "NMDS2")]), ]
year2022<- mds_scores_t012[mds_scores_t012$time == "t2", ][chull(mds_scores_t012[mds_scores_t012$time == 
                                                          "t2", c("NMDS1", "NMDS2")]), ]
hulldatyear<-rbind(year2020,year2021,year2022)

options(ggrepel.max.overlaps = 6)
nmds.plot <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t012, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment") +
  labs(title=paste0("Stress: ", round(ass.rel.t012_NMS$stress,3)))
 
print(nmds.plot)


# All other NMDS pairs
# treatments <- unique(mds_scores_t012$treatment)
# plots <- list()
# num_axes <- 5  

# for (i in 1:num_axes) {
#  for (j in (i+1):num_axes) {  
#    if (j <= num_axes && i != j) {  
#      log <- mds_scores_t012[mds_scores_t012$treatment == "log", ]
#      open <- mds_scores_t012[mds_scores_t012$treatment == "open", ]
#      
#      log_hull <- log[chull(log[[paste0("NMDS", i)]], log[[paste0("NMDS", j)]]), ]
#      open_hull <- open[chull(open[[paste0("NMDS", i)]], open[[paste0("NMDS", j)]]), ]
#      
#      hulldat <- rbind(log_hull, open_hull)
#      
#      plot_name <- paste0(i, "+", j)
      
#      plots[[plot_name]] <- ggplot() +
#        theme_bw() +
#        theme(panel.background = element_blank(),
#              panel.grid.major = element_blank(),
#              panel.grid.minor = element_blank(),
#              plot.background = element_blank(),
#              axis.text = element_text(size = 15),
#              axis.title = element_text(size = 15),
#              legend.title = element_text(size = 15),
#              legend.text = element_text(size = 10)) +
#        geom_text_repel(data = species.scores, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), label = species), alpha = 0.9, size = 3, col = 'darkgray', na.rm = TRUE) +
#        geom_polygon(data = hulldat, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), fill = treatment, group = treatment), alpha = 0.3) + 
#        scale_fill_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        geom_point(data = mds_scores_t012, aes(x = !!sym(paste0("NMDS", i)), y = !!sym(paste0("NMDS", j)), shape = block, col = treatment), size = 6) + scale_shape_manual(values = c(14, 15, 16, 17, 11, 18, 8), name = 'Block') +
#        scale_colour_manual(values = c("#63A088", "#56638A"), name = "Treatment") +
#        xlab(paste0("NMDS", i)) +
#        ylab(paste0("NMDS", j))
#    }
#  }
#}

#(plots$`1+2`+ plots$`1+3`)/ (plots$`1+4`+ plots$`1+5`)/(plots$`2+3` + plots$`2+4`)/ (plots$`2+5`+ plots$`3+4`)/ (plots$`3+5`+ plots$`4+5`) + plot_layout(guides ="collect") + plot_annotation(paste0("Stress:",round(ass.rel.t012_NMS$stress,3), " (k = 5)"))
```

### **Q2 Why are plant communities in fallen log patches different from patches in the open?**<br>
#### *Overview of results* <br>  

1. Soil K and P have similar PCA loadings. In subsequent analysis, we may simplify the model structure by keeping only either K or P and still be able to infer the effects of the other. 

2. Total soil C (Wilcoxon rank sum test, p = 0.025) and plant available N (Wilcoxon rank sum test, p = 0.031) are significantly higher in log patches than open patches 

2. Plant abundance and diversity have a variable relationship with different nutrient elements in different years.  

4. No significant relationships have been found between the composition of plants and soil nutrient tested by post-hoc permutation analysis on RDA. However, it is worth noting that the data may not represent the true effect of soil nutrients on plant composition, as the degree of freedom for each soil nutrient observation is quite small (df=1). Therefore, it is difficult to disentangle the effects of each soil nutrient element on the overall plant species composition. On the other hand, soil nutrient variables are plotted on the NMDS plots by regressing each variable to the unconstrained axes. It means that we cannot use these projections on the NMDS plots to infer the explanatory effects of nutrient elements on plant species composition. 

*2020* 

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix. 

1.	*Abundance* – The best model suggested by model dredging includes all nutrient elements except soil K as additive fixed factors. According to this inclusive model, the abundance of plants is significantly affected by soil N (p=0.002), P (p=0.037), C (p=0.036), and CEC (p=0.020). However, the direction of slopes of each element varies. 

2.	*Diversity* – The best model suggested by model dredging includes base cation (CEC), K and N as additive fixed factors. The Shannon diversity index in the plant community tends to be significantly higher with higher levels of plant-available nitrogen (p=0.001) and potassium (p=0.003).  

3.	*Composition* – Permutation test performed on Redundancy analysis (RDA) shows that there is no significant correlation between any of the nutrient elements and the composition of plant species. 

*2021* 

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix. 

1.	*Abundance* – The best model suggested by model dredging includes only K, N and P as additive fixed factors. According to this inclusive model, the abundance of plants is only significantly affected by soil P (p=0.009) suggesting that plant abundance tends to increase in phosphorus rich soils. 

2.	*Diversity* – The best model suggested by model dredging includes base cation (CEC) and P as additive fixed factors. The Shannon diversity index in the plant community tends to be significantly higher with higher levels of potassium (p=0.006). 

3.	*Composition* – Permutation test performed on Redundancy analysis (RDA) shows that there is no significant correlation between any of the nutrient elements and the composition of plant species. There is only a very weak explanatory power observed in the base cation (CEC: p=0.099) 

*2022* 

There are three response variables: count (Poisson), Shannon diversity index (zero-inflated glmer with Gaussian), and composition matrix. 

1.	*Abundance* – The best model suggested by model dredging includes only P and C as additive fixed factors. According to this inclusive model, the abundance of plants is only significantly affected by soil C (p=0.034) suggesting that plant abundance tends to increase in carbon rich soils. 

2.	*Diversity* – The best model suggested by model dredging includes N, K and P as additive fixed factors. The Shannon diversity index in the plant community tends to be significantly higher with higher levels of plant-available nitrogen (p=0.026) and potassium (p=0.004) but lower levels of soil P (p=0.009). 

3.	*Composition* – Permutation test performed on Redundancy analysis (RDA) shows that there is no significant correlation between any of the nutrient elements and the composition of plant species. 

#### *Statistical Methods* <br> 

1. We performed a principal component analysis using a correlation matrix to examine the multivariate relationships among six different soil properties. These soil properties are soil total carbon (C), potassium (K), phosphorus (P), plant available nitrogen (N), base cation (CEC), and pH. 

2. We used the Wilcoxon rank sum test to compare soil nutrient levels between log and open plots. 

3. Effect of soil nutrient on plant abundance. 

This analysis involves three types of data: (1) plant counts of all plots in 2020 (N = 221) before the experiment setup differentiated by the initial treatment "log" and "open"; (2) plant counts from insitu_log and insitu_open plots in 2021 (N = 86) and 2022 (N = 84) respectively, including species with unknown identity; and (3) soil nutrient data collected from one random log plot and one random open plot in each block (N = 14). 

Since independent nutrient variables were sampled at block level, this part of the analysis does not include block as the random term to avoid singularity issues. Nutrient data is paired to abundance data summarize at plot level in this analysis. Although the estimate of the slope may remain unaffected, the strength of correlation (i.e. p value) may be magnified with an increase in N, which is a calculation artefact. One of the proposed solutions is to recalculate plant abundance at block level to improve the presentation of data. However, we should pay attention to the df (i.e. df =1) of each nutrient element and decide whether the result is representative of the effect (*We should have a discussion on this*). 

We used a generalized linear model (GLM) with a Poisson distribution structure to model the effect of all soil components on the abundance of plant individuals (data from 2020, 2021, and 2022 respectively). Additionally, we performed a model dredging (using the MuMln package) to select the best model (delta =0) with a subset of soil variables that best describes the distribution of plant abundance. We approach the problem without bias by not holding prior assumptions about the important soil nutrient of interest. 

4. Effect of soil nutrient on plant diversity (Shannon diversity index = SDI) 

This analysis involves three types of data: (1) plot-level plant count for each species of all plots in 2020 before the experiment setup differentiated by the initial treatment “log” and “open”; and (2) plot-level plant count for each species from insitu_log and insitu_open plots in 2021 and 2022 respectively. All data used for diversity comparison excludes species with unknown identity. (3) soil nutrient data collected from one random log plot and one random open plot in each block (N = 14). (*Similar issue as described in 3.) 

We used the Shannon diversity index to describe the plant species diversity for each transect at the plot level. Similarly to the approach used in Q1, we used a zero-inflated glmer with a Gaussian distribution function to model the effect of all soil properties as additive terms on plant diversity. We did not include 'block' as a random term in the model, but the function glmmTMB is able to handle models without a random term. Similarly, we performed a model dredging (using the MuMln package) to select the best model (delta =0) with a subset of soil variables that best describes the distribution of plant diversity. 

5. Effect of soil nutrient on plant composition

We performed NMDS analyses similar to those described in the previous section. However, to enhance the visualization of data, we decided to present the plant species composition data summarized at the block level (N=14). This means that we will have one value for log and one value for open within each block. Additionally, this approach will offer an alternative perspective on the issue highlighted in points 3 and 4. We utilized envfit analyses from the Vegan package to fit soil components onto the nondimensional space. However, it is important to note that soil variables are regressed onto the unconstrained axes in the nondimensional space, and this does not necessarily represent their explanatory power. 

Similarly, as an alternative approach, we ran a Redundancy Analysis (RDA) to test the correlation between species composition (squared-root transformed) and all soil variables as additive terms. To avoid pseudo-replication, we excluded 'block' as either fixed effect or random effect. We tested the significance of the model and each soil variable term by using a permutation test (anova.cca function from vegan package). We plotted the first two RDA axes to visualize the impact of soil variables on plant species composition. 

#### *Analysis*<br>

##### PCA
```{r, warning=FALSE,message=FALSE, include=TRUE, results='hold',echo=FALSE}
library(ggplot2)
library(ggpubr)
library(dplyr)
library(lme4)
library(emmeans)
library(pscl)
library(glmmTMB)
library(tidyr)
library(DHARMa)
library(ggplot2)
library(AICcmodavg)
library(ggpubr)

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# Visualise data
Nu <- c("N", "P", "K", "C", "conductivity", "pH", "prewash.exch.ca", "prewash.exch.k", "prewash.exch.mg", "prewash.exch.na", "CEC")

# for (element in Nu) {
#    print(
#      ggplot(nutrient, aes(x = init, y= !!rlang::sym(element))) +
#      geom_boxplot() + 
#      theme_bw() +
#      labs(x="Plot treatment", y= element)
#    )
#}


nutrient.for.pca <- nutrient[,c(7:10,12,17)]
nutrient$blockinit <- paste(nutrient$block, nutrient$init)
rownames(nutrient.for.pca) <- nutrient$blockinit
nutrient.pca <- prcomp(nutrient.for.pca, center=TRUE, scale=TRUE)
biplot(nutrient.pca, xlim=c(-0.5,.5), ylim=c(-0.5,.5), col=c("grey","red"))
```

##### Nutrient composition comparison between log and open

```{r, include=TRUE, results='hold', fig.width = 8, fig.height = 8, warning=FALSE, message=FALSE,echo=FALSE}
library(ggplot2)
library(ggpubr)
library(dplyr)
library(lme4)
library(emmeans)
library(pscl)
library(glmmTMB)
library(tidyr)
library(DHARMa)
library(ggplot2)
library(AICcmodavg)
library(ggpubr)

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

Nu <- c("N", "P", "K", "C", "pH", "CEC")

wilcox_results <- data.frame(element = character(),
                                w = numeric(),
                                p_value = numeric(),
                                stringsAsFactors = FALSE)

# Perform Wilcoxon rank sum test for each element between treatments
nutrient$init <- as.factor(nutrient$init)
for (element in Nu) {
    result <- wilcox.test(get(element) ~ init, data = nutrient, exact=TRUE)
    wilcox_results <- rbind(wilcox_results, 
                               data.frame(element = element,
                                          w = result$statistic,
                                          p_value = result$p.value,
                                          stringsAsFactors = FALSE,
                                          row.names = NULL))
}

print(wilcox_results) # only organic carbon is significantly different between the two plot types

plots_list <- list()

for (element in c(Nu)) {
  if (element == "C" | element == "N") {
    plot <- ggplot(nutrient, aes(x = init, y = !!rlang::sym(element))) +
      geom_boxplot() + 
      theme_bw() +
      labs(x = NULL, y = element) + 
      scale_x_discrete(labels=c('log', 'open')) +
      geom_signif(comparisons = list(c("log", "open")),
                  map_signif_level = TRUE,
                  textsize = 5, vjust = 0.6, tip_length = 0) + 
      scale_y_continuous(expand = c(0,0.1))+
      theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank()) + 
      theme(axis.line = element_line(color = 'black'))
    
  } else {
    plot <- ggplot(nutrient, aes(x = init, y = !!rlang::sym(element))) +
      geom_boxplot() + 
      theme_bw() +
      labs(x = NULL, y = element) + 
      scale_x_discrete(labels=c('log', 'open')) +
      theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank()) + theme(axis.line = element_line(color = 'black'))
  }
  
  plots_list[[element]] <- plot
}

all.bp <- ggarrange(plotlist=plots_list, ncol=3, nrow=2, common.legend =TRUE, legend="bottom",align = "v")

all.bp <- annotate_figure(all.bp, bottom = "Plot treatment")
# Show the final plot
print(all.bp)
```

##### Abundance ~ nutrient composition 
```{r, include=TRUE, results='hold', warning=FALSE, message=FALSE,echo=FALSE}
library(ggplot2)
library(ggpubr)
library(dplyr)
library(lme4)
library(emmeans)
library(pscl)
library(glmmTMB)
library(tidyr)
library(DHARMa)
library(ggplot2)
library(AICcmodavg)
library(ggpubr)
require(vegan)
require(labdsv)
require(stringr)
require(ggrepel)
library(car)
library(sjPlot)
library(sjmisc)
library(sjlabelled)
library(MuMIn)

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# This community data set includes all species (including unidentified species)
comm <- read.csv("20-22_species_composition_data_w_unk.csv", header=T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)
#here#
# Split group info into columns for each variable.
mat<-separate(commtry, 107, c("time","block","transect","init", "treatment"), ":")
# names(mat) #check

# Add groupname using time, block, init columns.
# mat$grp1<-apply(mat[c(107:110)], 1, paste, collapse=":")
# mat$grp2<-apply(mat[c(107:111)], 1, paste, collapse=":")
# names(mat) #check

##### Abundance analysis for 2020 (t0) AND in-situ log and in-situ open plots in 2021 (t1) and 2022 (t2)
# 2020 df: the grouping variables kept are time X block X initial state.
# 2021 & 2022 df: the grouping variables kept are time X block X initial state X treatment.
# Each row is still a transect in a certain year.
df1 <- mat[which(mat$time=="t0"),]
df1 = df1 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df1)<-NULL # remove rownames
df1$grp1<-apply(df1[c(107:108,110)], 1, paste, collapse=":")

df2 <- mat[which(mat$time=="t1"),]
df2 <- df2[which(df2$treatment=="open" | df2$treatment=="insitu_log"), ]
df2 = df2 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df2)<-NULL # remove rownames
df2$grp1<-apply(df2[c(107:108,110:111)], 1, paste, collapse=":")

df3 <- mat[which(mat$time=="t2"),]
df3 <- df3[which(df3$treatment=="open" | df3$treatment=="insitu_log"), ]
df3 = df3 %>% mutate(across(.cols=1:106,.fns=as.numeric))
rownames(df3)<-NULL # remove rownames
df3$grp1<-apply(df3[c(107:108,110:111)], 1, paste, collapse=":")

# Average out observations across time X block X treatment (group variable).
# This gives average number of plants in each treatment in each block.
## Original code sum the observations blocksum1<-rowsum(df1[,c(1:106)], group=df1$grp1)
grp1 <- df1[, "grp1"]
blocksum1 <- aggregate(df1[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

grp1 <- df2[, "grp1"]
blocksum2 <- aggregate(df2[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

grp1 <- df3[, "grp1"]
blocksum3 <- aggregate(df3[, c(1:106)], by = list(grp1), FUN = function(x) rowMeans(t(x)))

# Add in group vars.
nublock1<-separate(blocksum1, 1, c("time","block", "init"), ":")
nublock1$total<-rowSums(nublock1[,c(4:109)])
nublock1$presence<-ifelse(nublock1$total > 0,  1, 0)

nublock2<-separate(blocksum2, 1, c("time","block","init", "treatment"), ":")
nublock2$total<-rowSums(nublock2[,c(5:110)])
nublock2$presence<-ifelse(nublock2$total > 0,  1, 0)
nublock2 <- nublock2[,c(1:3, 5:112)]

nublock3<-separate(blocksum3, 1, c("time","block","init", "treatment"), ":")
nublock3$total<-rowSums(nublock3[,c(5:110)])
nublock3$presence<-ifelse(nublock3$total > 0,  1, 0)
nublock3 <- nublock3[,c(1:3, 5:112)]

# Put all data in one df
dat_t0_insitu <- rbind(nublock1, nublock2, nublock3)

# Look at plant abundance in log vs open 
# Look at range of data
# range(nublock1$total)
# range(nublock2$total)
# range(nublock3$total)

# distribution of data
# ggplot(nublock1, aes(sample=total)) + 
#  stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock1$total))) + 
#  stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock1$total))) +
#    ggtitle("Poisson")# 2020 data fits a poisson dist.

# ggplot(nublock1, aes(sample = total)) + geom_qq(distribution = qnorm) + geom_qq_line(distribution = qnorm) + ggtitle("normal")

# ggplot(nublock2, aes(sample=total)) + 
#     stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock2$total))) + 
#     stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock2$total))) +
#     ggtitle("Poisson")

# ggplot(nublock2, aes(sample = total)) + geom_qq(distribution = qnorm) + geom_qq_line(distribution = qnorm) + ggtitle("normal")

# ggplot(nublock3, aes(sample=total)) + 
#     stat_qq(distribution=qpois, dparams = c(lambda=mean(nublock3$total))) + 
#     stat_qq_line(distribution=qpois, dparams = c(lambda=mean(nublock3$total))) +
#     ggtitle("Poisson") # 2022 data fits a poisson dist.

#ggplot(nublock3, aes(sample = total)) + geom_qq(distribution = qnorm) + geom_qq_line(distribution = qnorm) + ggtitle("normal")

## Original code with two #
## Abundance analysis for 2020 (t0) AND in-situ log and in-situ open plots in 2021 (t1) and 2022 (t2)

## Sum observations across initial X transect X time X  block X treatment (group variable).
## This gives number of plants in each row observation (transect level).
## blocksum2<-rowsum(df2[,c(1:106)], group=df2$grp2)
## blocksum2$grps<-rownames(blocksum2)
## rownames(blocksum2)<-NULL # remove rownames

## Add in group vars.
## nublock2<-separate(blocksum2, 107, c("time","block","transect","init", "treatment"), ":")
## nublock2$total<-rowSums(nublock2[,c(1:106)])
## nublock2$presence<-ifelse(nublock2$total > 0,  1, 0)

## Subset data where before treatments installed (t0), in-situ log and in-situ open from t1 and t2 are included.
## Hence only absolute log effect and absolute open effect are concerned
## dat_t0_insitu<-nublock2[which(nublock2$time=="t0" |  nublock2$treatment=="open" |  nublock2$treatment=="insitu_log"),]

# look at plant abundance in log vs open 
# look at range of data - what family should i use? 
# range(dat_t0_insitu$total)
nutrient_join <- nutrient[,c(1,3, 7:8,10,12,17)]
nutrient_join$P <- log10(nutrient_join$P)
dat_t0_insitu <- inner_join(dat_t0_insitu, nutrient_join, by = c("init", "block"))

# since samples from t1 and t2 from are mainly from the same plots as t0. These are not independent replicates and tend to correlated with each other.
# including year and block as random effects
# (1|year) + (1|block) as we think the effect of init on total is the same (slope) but the intercept differ amongst block and year
# but since we have a greater number of sample from t0, data from t0 will contribute more to the variance in abundance.
# see https://bookdown.org/steve_midway/DAR/random-effects.html#pld-example
# model avg https://uoftcoders.github.io/rcourse/lec09-model-selection.html

# 2020 - 2022 #
dat_t0_insitu$time <- as.factor(dat_t0_insitu$time)
mod.dredge.allyear <- lmer(total~ N+ P + C + CEC + pH + (1|time), 
                         data = dat_t0_insitu, 
                         na.action = "na.fail")
# vif(mod.dredge) # no collinearity
dredge_allyear <- dredge(mod.dredge.allyear, extra = "adjR^2") # candidate model including all nutrient elements are fairly good compared to the best fitting model
avg_allyear<- summary(model.avg(dredge_allyear, cumsum(weight) <= .95))
avg_allyear_full <- as.data.frame(avg_allyear$coefmat.full)
print(sw(model.avg(dredge_allyear, cumsum(weight) <= .95)))
# dredgetable_allyear <- subset(dredge_allyear, cumsum(weight) <= .95) # look at how many tables are included

## best.allyear <- glm(total~ N, data = dat_t0_insitu, family = gaussian)
## tab_model(best.allyear,mod.dredge.allyear, file="mod.abun_nu_allyear.html",  dv.labels = c("Best model", "Inclusive model"), transform = NULL, show.est = TRUE, show.se = TRUE, title = "Abundance ~ soil nutrient [2020-2022]")
## htmltools::includeHTML("mod.abun_nu_allyear.html")

# only 2022 #
mod.dredge.2022 <- glm(total ~ N + P + C + CEC + pH, 
                        data = dat_t0_insitu,
                        subset = (time == "t2"),
                        family = gaussian, 
                        na.action = "na.fail")
# vif(mod.dredge.2022) # no collinearity
dredge_2022 <- dredge(mod.dredge.2022, extra = "adjR^2") # candidate model including all nutrient elements are fairly good compared to the best fitting model
avg_2022<- summary(model.avg(dredge_2022, cumsum(weight) <= .95))
avg_2022_full <- as.data.frame(avg_2022$coefmat.full)
print(sw(model.avg(dredge_2022, cumsum(weight) <= .95))) # relative importance, sum of Akaike Weigths for each variable across all models including that variable
## best.2022 <- glm(total~ pH , data = dat_t0_insitu,subset = (time == "t2"), family = gaussian)
## tab_model(best.2022,mod.dredge.2022, file="mod.abun_nu_2022.html", dv.labels = c("Best model", "Inclusive model (2022)"), transform = NULL, show.est = TRUE, show.se = TRUE, title = "Abundance ~ soil nutrient [2022]")
## htmltools::includeHTML("mod.abun_nu_2022.html")

# only 2021 #
mod.dredge.2021 <- glm(total~ N+ P + C + CEC + pH,
                       data = dat_t0_insitu, 
                       subset = (time == "t1"), 
                       family = gaussian,
                       na.action = "na.fail")

# vif(mod.dredge.2021) # no collinearity
dredge_2021 <- dredge(mod.dredge.2021, extra = "adjR^2")
avg_2021<- summary(model.avg(dredge_2021, cumsum(weight) <= .95))
avg_2021_full <- as.data.frame(avg_2021$coefmat.full)
print(sw(model.avg(dredge_2021, cumsum(weight) <= .95)))
# tab_model(best.2021,mod.dredge.2021, file="mod.abun_nu_2021.html", dv.labels = c("Best model", "Inclusive model"), transform = NULL, show.est = TRUE, show.se = TRUE, title = "Abundance ~ soil nutrient [2021]")
# htmltools::includeHTML("mod.abun_nu_2021.html")

# only 2020 #
mod.dredge.2020 <- glm(total~ N+ P + C + CEC + pH, 
                       data = dat_t0_insitu, 
                       subset = (time == "t0"), 
                       family = gaussian,
                       na.action = "na.fail")
# vif(mod.dredge.2020) # no collinearity
dredge_2020 <- dredge(mod.dredge.2020, extra = "adjR^2")
avg_2020<- summary(model.avg(dredge_2020, cumsum(weight) <= .95))
avg_2020_full <- as.data.frame(avg_2020$coefmat.full)
print(sw(model.avg(dredge_2020, cumsum(weight) <= .95)))
# tab_model(best.2020, mod.dredge.2020, file="mod.abun_nu_2020.html", dv.labels = c("Best model", "Inclusive model"), transform = NULL, show.est = TRUE, show.se = TRUE, title = "Abundance ~ soil nutrient [2020]")
# htmltools::includeHTML("mod.abun_nu_2020.html")
```

##### Diversity ~ nutrient composition
```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results='markup', fig.width =8, fig.height=8,echo=FALSE}
require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)
require(lmerTest)
require(performance)
require(ggpubr)
require(DHARMa)
require(MuMIn)
require(sjPlot)
require(sjmisc)

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# This dataset does not include unknown data.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify
commsub<-comm[,c(15,10,13)] 

# group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-labdsv::matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1  # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block","transect","init","treatment"), ":")
# names(mat) #check

# Add groupname using time, block, init columns
mat$grp<-apply(mat[c(88:92)], 1, paste, collapse=":")
# names(mat) #check

# Another df where the grouping variables are time, block, transect and initial state.
# Each row is a transect in a certain year.
df<-mat[,c(1:87,93)]
df2 = df %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

###### Species diversity analysis for 2020 - 2022 data (Shannon diversity on transect level) 
numat = mat %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
numat<-numat[which(numat$time=="t0" |  numat$treatment=="open" |  numat$treatment=="insitu_log"),]

# sum species for each group (grouped by init, block, time)
nudat<-numat%>% 
  group_by(time, block, init) %>% summarise(across(where(is.numeric), sum)) #42rows

# make a data frame
dat<-as.data.frame(nudat) # this df contains transect levels from all years

#estimate diversity for each row/group. don't include 'x' 

# no groups, just estimate diversity of each row
est<-dat[,c(4:89)]
dat$diversity<-diversity(est, index='shannon') 
nutrient_join <- nutrient[,c(1,3,7:8, 10, 12,17)]
nutrient_join$P <- log10(nutrient_join$P)
dat <- inner_join(dat, nutrient_join, by = c("init", "block"))

# distribution of data is pretty normal
# hist(dat$diversity)

## We used a hurdle model since the data is zero-inflated
## separate into zero and non-zero observations
## dat$non_zero <- ifelse(dat$diversity > 0, 1, 0)

# Non-zero data is an approximal Gaussian distribution
# hist(dat$diversity[dat$non_zero ==1], xlab = "Shannon diversity index (non-zero)", main = "Histogram of Shannon diversity index (non-zero, all years, transect level)") # visually it resembles a lot like a Gaussian distribution 

## Gaussian distribution produced the best-fitting ggplot
## dat_nonzerodat <- dat[dat$non_zero == 1, ]
## ggplot(dat_nonzerodat, aes(sample = diversity)) + geom_qq(distribution = qnorm) + geom_qq_line(distribution = qnorm) + ggtitle("normal")

# 2020-2022 #
# di.mod.2022 <- glmmTMB(diversity ~ init+(1|block), data=subset(dat, time == "t2"), ziformula=~1, family = gaussian)
# di.mod.t012 <- glmmTMB(diversity ~ N + P + K + C + CEC + (1|time), data=dat, ziformula=~1, family = gaussian, na.action = "na.fail")
# dredge_allyear <- dredge(di.mod.t012)
# best.allyear <- glmmTMB(diversity~ N + P + K + (1|time), data=dat, ziformula=~1, family = gaussian)
# tab_model(best.allyear, file="mod.diver_nu_allyear.html", dv.labels = c("Best model"), title="Shannon diversity index ~ soil nutrient[2020-2022]")
# htmltools::includeHTML("mod.diver_nu_allyear.html")
di.mod.allyear <- lmer(diversity ~ N + P + C + CEC + pH + (1|time),
                    data =dat, 
                    na.action= "na.fail")
dredge_allyear <- dredge(di.mod.allyear, extra = "adjR^2")
avg_allyear<- summary(model.avg(dredge_allyear, cumsum(weight) <= .95))
print(as.data.frame(avg_allyear$coefmat.full))
print(sw(model.avg(dredge_allyear, cumsum(weight) <= .95)))

# 2020 #
di.mod.2020 <- lm(diversity ~ N + P + C + CEC + pH,
                    data =dat, 
                    subset = (time == "t0"),
                    na.action= "na.fail")
dredge_2020 <- dredge(di.mod.2020, extra = "adjR^2")
avg_2020<- summary(model.avg(dredge_2020, cumsum(weight) <= .95))
print(as.data.frame(avg_2020$coefmat.full))
print(sw(model.avg(dredge_2020, cumsum(weight) <= .95)))
## tab_model(best.t0, file="mod.diver_nu_2020.html", dv.labels = "Best model", title="[2020]glmmTMB(diversity ~ CEC + K + N, data =dat_t0, ziformula=~1, family = gaussian)", transform = NULL, show.est = TRUE, show.se = TRUE)
## htmltools::includeHTML("mod.diver_nu_2020.html") 

# 2021 #
di.mod.2021 <- lm(diversity ~ N + P + C + CEC + pH,
                    data =dat, 
                    subset = (time == "t1"),
                    na.action= "na.fail")
dredge_2021 <- dredge(di.mod.2021, extra = "adjR^2")
avg_2021<- summary(model.avg(dredge_2021, cumsum(weight) <= .95))
print(as.data.frame(avg_2021$coefmat.full))
print(sw(model.avg(dredge_2021, cumsum(weight) <= .95)))
## tab_model(best.t1, file="mod.diver_nu_2021.html", dv.labels = "Best model", title="[2021]glmmTMB(diversity ~ CEC + P, data =dat_t1, ziformula=~1, family = gaussian)", transform = NULL, show.est = TRUE, show.se = TRUE)
## htmltools::includeHTML("mod.diver_nu_2021.html")

# 2022 #
di.mod.2022 <- lm(diversity ~ N + P + C + CEC + pH,
                    data =dat, 
                    subset = (time == "t2"),
                    na.action= "na.fail")
dredge_2022 <- dredge(di.mod.2022, extra = "adjR^2")
avg_2022<- summary(model.avg(dredge_2022, cumsum(weight) <= .95))
print(as.data.frame(avg_2022$coefmat.full))
print(sw(model.avg(dredge_2022, cumsum(weight) <= .95)))
## tab_model(best.t2, file="mod.diver_nu_2022.html", dv.labels = "Best model", title=" [2022]glmmTMB(diversity ~ N + P + K, data =dat_t2, ziformula=~1, family = gaussian)", transform = NULL, show.est = TRUE, show.se = TRUE)
## htmltools::includeHTML("mod.diver_nu_2022.html")
```

##### Composition ~ nutrient composition
```{r, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results='markup', fig.width =8, fig.height=8,echo=FALSE}
# packages
library(tidyverse)
require(vegan)
require(dplyr)
require(tidyr)
require(labdsv)
require(stringr)
require(ggplot2)
require(ggrepel)
require(lme4)
require(emmeans)
require(lmerTest)
require(performance)
require(ggpubr)
library(pscl)
library(glmmTMB)
library(DHARMa)
library(AICcmodavg)
library(patchwork)
```

*2020*

```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results='markup', fig.width=12, fig.height=6,echo=FALSE}
# Data wrangling
# This data set does not include unknown data.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# Make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block","transect","init","treatment"), ":")
# names(mat) #check

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t0"),]
mat2$grp<-apply(mat2[c(89,91)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:87, 93)]
df2 = df %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 88, c("block", "init"), ":") # just looking at time, block & initial treatment

# want to sum across transects in same block X init treatment
nublock$sumgrp<-apply(mat2[c(89, 91)], 1, paste, collapse=":")
# head(nublock)

# sum observations across initial X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 3 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:87)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
# nrow(blocksum) # it is 14 rows as expected 

## expand again
blocksum<-separate(blocksum, 88, c("block", "init"), ":")
nutrient_join <- nutrient[,c(1,3,7:10, 12,17)]
blocksum <- inner_join(blocksum, nutrient_join, by = c("init", "block"))

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t0<-blocksum[,c(1:87)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init
group_block<-blocksum$block
group_nutrient<-blocksum[,c(90:95)]

# MDS 
ass.rel.t0<-decostand(assemblies_t0, method='hel') #standardize assemblies 
ass.rel.t0_NMS <- metaMDS(ass.rel.t0, distance = 'bray', k = 2, trace = FALSE) # run MDS 
# stressplot(ass.rel.t0_NMS) # check fit
en.nutrient = envfit(ass.rel.t0_NMS, group_nutrient, permutations = 999, na.rm = TRUE)
# plot(ass.rel.t0_NMS) 
# plot(en.nutrient)

# scores
mds_scores_t0<-as.data.frame(vegan::scores(ass.rel.t0_NMS)$sites) # extract scores
mds_scores_t0$site<-rownames(vegan::scores(ass.rel.t0_NMS)$sites) # extract names 
mds_scores_t0$treatment<-group_init # grouping factor 1 
mds_scores_t0$block<-group_block # grouping factor 2 
en_coord_cont = as.data.frame(vegan::scores(en.nutrient, "vectors")) * ordiArrowMul(en.nutrient)

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

#### Redundancy analysis
# can look at significance of model where initial treatment and block explain variation in community
trt_tot_2<-rda(ass.rel.t0 ~ ., data = blocksum[,c(90:95)]) # run model using standardized data 
# summary(trt_tot_2)
anova.cca(trt_tot_2, step=1000, by="term") ## test for model significance

# Plotting rda
perc <- round(100*(summary(trt_tot_2)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_tot_2, display="bp", choices=c(1, 2), scaling=1)
sc_sp <-vegan::scores(trt_tot_2, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_tot_2, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_tot_2)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_tot_2,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.3,.3), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 
text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

points (sc_si, col = sc_si$treatment[c("#63A088","#56638A")], pch = 21 , cex=2, bg=c("#63A088","#56638A"))

text(sc_si, # adjust text coordinates to avoid overlap with points 
     labels = sc_si$block, 
     col = "white", 
     font = 2, # bold
     cex = 0.6)

legend("topleft",  legend=c("log", "open"),
       col=c("#63A088","#56638A") ,pch=21, cex=0.8, inset = 0.01, box.lty=1)
# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] -0.05, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] , 
     labels = rownames(sc_bp), 
     col = "black", 
     cex = 1, 
     font = 2)

# Using varpart to look at contributions of initial treatment and block
# var.mod2<-varpart(ass.rel.t0, init, block) # run model on standardized data
# plot(var.mod2, bg=c("hotpink","skyblue"))
# mtext("X1= Treatment; X2=Block", side=3)

# can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
# trt_Frac<-rda(ass.rel.t0, init, block) # partial rda model
# summary(trt_Frac) 
# RsquareAdj(trt_Frac)$adj.r.squared #explanatory power
# anova.cca(trt_Frac) ## this tells us if first condition, init, significantly contributes to overall variance explanation. 

# Extracting species scores and plotting 
# Species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t0_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t0[mds_scores_t0$treatment == "log", ][chull(mds_scores_t0[mds_scores_t0$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t0[mds_scores_t0$treatment == "open", ][chull(mds_scores_t0[mds_scores_t0$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

nmds.plot.sp <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 10),
        axis.title=element_text(size=15),
        legend.title=element_text(size=15), 
        legend.text=element_text(size=10))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+
  scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t0, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ 
  scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  labs(title=paste0("Stress: ", round(ass.rel.t0_NMS$stress,3)))

nmds.plot.nutrient <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 10),
        axis.title=element_text(size=15),
        legend.title=element_text(size=15), 
        legend.text=element_text(size=10))+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+
  scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t0, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ 
  scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
       data = en_coord_cont, size =0.5, alpha = 0.5, colour = "grey30") +
     geom_text(data = en_coord_cont, aes(x = NMDS1, y = NMDS2), colour = "grey30", 
       fontface = "bold", label = row.names(en_coord_cont))

# put both nmds plots together
print(en.nutrient) ########## it is basically saying most of the nutrient does not affect the composition of plants.
(nmds.plot.sp + theme(legend.position = "none")) + nmds.plot.nutrient + plot_layout(guides = "collect") + plot_annotation(title = 'Plant composition: 2020')
```

*2021*

```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results='markup', fig.width=12, fig.height=6,echo=FALSE}
# Data wrangling
# This data set does not include unidentified species.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# Make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block","transect","init","treatment"), ":")
# names(mat) #check

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t1" &  mat$treatment=="open" | mat$time=="t1" & mat$treatment=="insitu_log"),]
mat2$grp<-apply(mat2[c(89,91)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:87, 93)]
df2 = df %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 88, c("block", "init"), ":") # just looking at time, block & initial treatment

# want to sum across transects in same block X init treatment
nublock$sumgrp<-apply(mat2[c(89, 91)], 1, paste, collapse=":")
# head(nublock)

# sum observations across initial X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 3 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:87)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
# nrow(blocksum) # it is 14 rows as expected 

## expand again
blocksum<-separate(blocksum, 88, c("block", "init"), ":")
nutrient_join <- nutrient[,c(1,3,7:10, 12,17)]
blocksum <- inner_join(blocksum, nutrient_join, by = c("init", "block"))

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t1<-blocksum[,c(1:87)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init
group_block<-blocksum$block
group_nutrient<-blocksum[,c(90:95)]

# MDS 
ass.rel.t1<-decostand(assemblies_t1, method='hel') #standardize assemblies 
ass.rel.t1_NMS <- metaMDS(ass.rel.t1, distance = 'bray', k = 2, trace=FALSE) # run MDS 
# stressplot(ass.rel.t1_NMS) # check fit
en.nutrient = envfit(ass.rel.t1_NMS, group_nutrient, permutations = 999, na.rm = TRUE)
# plot(ass.rel.t1_NMS) 
# plot(en.nutrient)

# scores
mds_scores_t1<-as.data.frame(vegan::scores(ass.rel.t1_NMS)$sites) # extract scores
mds_scores_t1$site<-rownames(vegan::scores(ass.rel.t1_NMS)$sites) # extract names 
mds_scores_t1$treatment<-group_init # grouping factor 1 
mds_scores_t1$block<-group_block # grouping factor 2 
en_coord_cont = as.data.frame(vegan::scores(en.nutrient, "vectors")) * ordiArrowMul(en.nutrient)

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor

#### rda model analysis & results #### 
trt_tot_2<-rda(ass.rel.t1 ~ ., data = blocksum[,c(90:95)]) # run model using standardized data 
# summary(trt_tot_2)
anova.cca(trt_tot_2, step=1000, by="term") ## test for model significance

# Plotting rda
perc <- round(100*(summary(trt_tot_2)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_tot_2, display="bp", choices=c(1, 2), scaling=1)
sc_sp <-vegan::scores(trt_tot_2, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_tot_2, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_tot_2)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_tot_2,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.3,.3), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 
text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

points (sc_si, col = sc_si$treatment[c("#63A088","#56638A")], pch = 21 , cex=2, bg=c("#63A088","#56638A"))

text(sc_si, # adjust text coordinates to avoid overlap with points 
     labels = sc_si$block, 
     col = "white", 
     font = 2, # bold
     cex = 0.6)

legend("topleft",  legend=c("log", "open"),
       col=c("#63A088","#56638A") ,pch=21, cex=0.8, inset = 0.01, box.lty=1)
# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] +0.05, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] , 
     labels = rownames(sc_bp), 
     col = "black", 
     cex = 1, 
     font = 2)

# can model using varpart to look at contributions of initial treatment and block
# var.mod2<-varpart(ass.rel.t1, init, block) # run model on standardized data
# plot(var.mod2, bg=c("hotpink","skyblue"))
# mtext("X1= Treatment; X2=Block", side=3)

## can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
# trt_Frac<-rda(ass.rel.t1, init, block) # partial rda model
# summary(trt_Frac) 
# RsquareAdj(trt_Frac)$adj.r.squared #explanatory power
# anova.cca(trt_Frac) ## this tells us if first condition, init, significantly contributes to overall variance explanation. 

### extracting species scores and plotting 
# species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t1_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t1[mds_scores_t1$treatment == "log", ][chull(mds_scores_t1[mds_scores_t1$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t1[mds_scores_t1$treatment == "open", ][chull(mds_scores_t1[mds_scores_t1$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

nmds.plot.sp <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t1, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  labs(title=paste0("Stress: ", round(ass.rel.t1_NMS$stress,3)))

nmds.plot.nutrient <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+
  scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t1, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ 
  scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
       data = en_coord_cont, size =0.5, alpha = 0.5, colour = "grey30") +
     geom_text(data = en_coord_cont, aes(x = NMDS1, y = NMDS2), colour = "grey30", 
       fontface = "bold", label = row.names(en_coord_cont))+
  labs(title=paste0("Stress: ", round(ass.rel.t1_NMS$stress,3)))

print(en.nutrient) ########## it is basically saying most of the nutrient does not affect the composition of plants.
(nmds.plot.sp + theme(legend.position = "none")) + nmds.plot.nutrient + plot_layout(guides = "collect") + plot_annotation(title = 'Plant composition: 2020')
```

*2022*

```{r, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE,fig.width=12, fig.height=6,echo=FALSE}
# Data wrangling
# This data set does not include unknown data.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# Make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block","transect","init","treatment"), ":")
# names(mat) #check

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

#####
# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat2 <- mat[which(mat$time=="t2" &  mat$treatment=="open" | mat$time=="t2" & mat$treatment=="insitu_log"),]
mat2$grp<-apply(mat2[c(89,91)], 1, paste, collapse=":") # block, init as grouping
# names(mat2) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat2[,c(1:87, 93)]
df2 = df %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 88, c("block", "init"), ":") # just looking at time, block & initial treatment

# want to sum across transects in same block X init treatment
nublock$sumgrp<-apply(mat2[c(89, 91)], 1, paste, collapse=":")
# head(nublock)

# sum observations across initial X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 3 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:87)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
# nrow(blocksum) # it is 14 rows as expected 

## expand again
blocksum<-separate(blocksum, 88, c("block", "init"), ":")
nutrient_join <- nutrient[,c(1,3,7:10, 12,17)]
blocksum <- inner_join(blocksum, nutrient_join, by = c("init", "block"))

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t2<-blocksum[,c(1:87)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init
group_block<-blocksum$block
group_nutrient<-blocksum[,c(90:95)]

# MDS 
ass.rel.t2<-decostand(assemblies_t2, method='hel') #standardize assemblies 
ass.rel.t2_NMS <- metaMDS(ass.rel.t2, distance = 'bray', k = 2, trace = FALSE) # run MDS 
# stressplot(ass.rel.t2_NMS) # check fit
en.nutrient = envfit(ass.rel.t2_NMS, group_nutrient, permutations = 999, na.rm = TRUE)
# plot(ass.rel.t2_NMS) 
# plot(en.nutrient)

# we have created our NMS as ass.rel.t2_NMS
# scores
mds_scores_t2<-as.data.frame(vegan::scores(ass.rel.t2_NMS)$sites) # extract scores
mds_scores_t2$site<-rownames(vegan::scores(ass.rel.t2_NMS)$sites) # extract names 
mds_scores_t2$treatment<-group_init # grouping factor 1 
mds_scores_t2$block<-group_block # grouping factor 2 
mds_scores_t2 <- cbind(mds_scores_t2, group_nutrient)
en_coord_cont = as.data.frame(vegan::scores(en.nutrient, "vectors")) * ordiArrowMul(en.nutrient)

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor
# nutri<-as.factor(group_nutrient) # this might be a mistake

#### rda model analysis & results #### 
trt_tot_2<-rda(ass.rel.t2 ~ ., data = blocksum[,c(90:95)]) # run model using standardized data 
# summary(trt_tot_2)
anova.cca(trt_tot_2, step=1000, by="term") ## test for model significance

# Plotting rda
perc <- round(100*(summary(trt_tot_2)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_tot_2, display="bp", choices=c(1, 2), scaling=1)
sc_sp <-vegan::scores(trt_tot_2, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_tot_2, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_tot_2)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_tot_2,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.3,.3), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 
text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

points (sc_si, col = sc_si$treatment[c("#63A088","#56638A")], pch = 21 , cex=2, bg=c("#63A088","#56638A"))

text(sc_si, # adjust text coordinates to avoid overlap with points 
     labels = sc_si$block, 
     col = "white", 
     font = 2, # bold
     cex = 0.6)

legend("topleft",  legend=c("log", "open"),
       col=c("#63A088","#56638A") ,pch=21, cex=0.8, inset = 0.01, box.lty=1)
# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] +0.05, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] , 
     labels = rownames(sc_bp), 
     col = "black", 
     cex = 1, 
     font = 2)

# can model using varpart to look at contributions of initial treatment and block
# var.mod2<-varpart(ass.rel.t2, init, block) # run model on standardized data
# plot(var.mod2, bg=c("hotpink","skyblue"))
# mtext("X1= initial treatment; X2=Block", side=3)

## can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
# trt_Frac<-rda(ass.rel.t2, init, block) # partial rda model
# summary(trt_Frac) 
# RsquareAdj(trt_Frac)$adj.r.squared #explanatory power
#anova.cca(trt_Frac) ## this tells us if first condition, init, significantly contributes to overall variance explanation. 

### extracting species scores and plotting 
# species scores
species.scores.t2 <-as.data.frame(vegan::scores(ass.rel.t2_NMS,"species")) ## some species don't have scores
species.scores.t2$species<-rownames(species.scores.t2) 

### NMDS 1 and 2 
log<-mds_scores_t2[mds_scores_t2$treatment == "log", ][chull(mds_scores_t2[mds_scores_t2$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t2[mds_scores_t2$treatment == "open", ][chull(mds_scores_t2[mds_scores_t2$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

nmds.plot.sp <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores.t2, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray',na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t2, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  labs(title=paste0("Stress: ", round(ass.rel.t2_NMS$stress,3)))

nmds.plot.nutrient <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t2, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
       data = en_coord_cont, size =0.5, alpha = 0.5, colour = "grey30") +
     geom_text(data = en_coord_cont, aes(x = NMDS1, y = NMDS2), colour = "grey30", 
       fontface = "bold", label = row.names(en_coord_cont))+
  labs(title=paste0("Stress: ", round(ass.rel.t2_NMS$stress,3)))

print(en.nutrient) ########## it is basically saying most of the nutrient does not affect the composition of plants.
(nmds.plot.sp + theme(legend.position = "none")) + nmds.plot.nutrient + plot_layout(guides = "collect") + plot_annotation(title = 'Plant composition: 2020')
```

*2020-2022*
```{r, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=FALSE,fig.width=12, fig.height=6,echo=FALSE}
# Data wrangling
# This data set does not include unknown data.
comm <- read.csv("20-22_species_composition_data_no_unk.csv", header = T)

# Remove the locations surveyed in 2021 and 2022 that were not surveyed in 2020 - aka, cm=0, cm=21, cm = 22, cm = 29.
comm<-comm[which(comm$cm_location!=21 & comm$cm_location!=0 & comm$cm_location!=22 & comm$cm_location!=29),]

# Make a group name for each row
comm$grp<-apply(comm[c(1,3,5,6,7)], 1, paste, collapse=":") # timepoint, block, transect_name, initial state

# Need to make each row a community using matrify.
commsub<-comm[,c(15,10,13)] # group, species_code, and count of each species for each transect. transects are rows.
commsub <-as.data.frame(commsub)
commtry<-matrify(commsub) # make it an expanded species matrix 
commtry$x[which(is.na(commtry$x))] <- 1 # "x" means that there were no individuals in the transect, but we are going to keep track of this as if it were a species
# ncol(commtry) # how many species are we working with in our community matrix

# Store grouping row names as a column, then remove rownames.
commtry$grps<-rownames(commtry)
rownames(commtry)<-NULL
# names(commtry)

# Split group info into columns for each variable
mat<-separate(commtry, 88, c("time","block","transect","init","treatment"), ":")
# names(mat) #check

# Set up nutrient analysis data
nutrient <- read.csv("Nutrient.csv", header = T)
nutrient <-separate(nutrient,2 , c("block","plot"), "_")
nutrient <- nutrient[,2:18]

# subset data where all t0 communities, insitu log and insitu open communities at t1 and t2 are included.
mat3 <- mat[which(mat$time=="t0" |  mat$treatment=="open" | mat$treatment=="insitu_log"),]
mat3$grp<-apply(mat3[c(88,89,91)], 1, paste, collapse=":") # block, init as grouping
# names(mat3) #check

# another df where the grouping variables are time, block and initial state
# each row is a transect in a certain year.
df<-mat3[,c(1:87, 93)]
df2 = df %>% mutate(across(.cols=1:87,.fns=as.numeric)) # make everything numeric
rownames(df2)<-NULL # remove rownames

## new with group vars
nublock<-separate(df2, 88, c("time", "block", "init"), ":") # just looking at time, block & initial treatment

# want to sum across transects in same block X init treatment
nublock$sumgrp<-apply(mat3[c(88,89, 91)], 1, paste, collapse=":")
# head(nublock)

# sum observations across initial X  block (group variable)
# this gives number of plants in each transect TYPE for each year in each block. should be 2 types X 3 years X 7 blocks rows 
blocksum<-rowsum(nublock[,c(1:87)], group=nublock$sumgrp)
blocksum$grps<-rownames(blocksum)
rownames(blocksum)<-NULL # remove rownames
nrow(blocksum) # it is 42 rows as expected 

##  expand again
blocksum<-separate(blocksum, 88, c("time", "block", "init"), ":")
nutrient_join <- nutrient[,c(1,3,7:10, 12,17)]
blocksum <- inner_join(blocksum, nutrient_join, by = c("init", "block"))

# at the moment this includes where there were no plants ("x" column in matrix)
assemblies_t012<-blocksum[,c(1:87)]

# group - these are the treatment variables that need to be separately fed into the MDS analaysis from the community analysis.
group_init<-blocksum$init
group_block<-blocksum$block
group_time<-blocksum$time
group_nutrient<-blocksum[,c(91:94,96)]

# MDS 
ass.rel.t012<-decostand(assemblies_t012, method='hel') #standardize assemblies 
ass.rel.t012_NMS <- metaMDS(ass.rel.t012, distance = 'bray', k = 2, trace = FALSE) # run MDS 
# stressplot(ass.rel.t012_NMS) # check fit
en.nutrient = envfit(ass.rel.t012_NMS, group_nutrient, permutations = 999, na.rm = TRUE)
# plot(ass.rel.t012_NMS) 
# plot(en.nutrient)
print(en.nutrient) ########## it is basically saying most of the nutrient does not affect the composition of plants.

# scores
mds_scores_t012<-as.data.frame(vegan::scores(ass.rel.t012_NMS)$sites) # extract scores
mds_scores_t012$site<-rownames(vegan::scores(ass.rel.t012_NMS)$sites) # extract names 
mds_scores_t012$treatment<-group_init # grouping factor 1 
mds_scores_t012$block<-group_block # grouping factor 2 
mds_scores_t012$time<-group_time # grouping factor 3
mds_scores_t012 <- cbind(mds_scores_t012, group_nutrient)
en_coord_cont = as.data.frame(vegan::scores(en.nutrient, "vectors")) * ordiArrowMul(en.nutrient)

# explaining factors
init<-as.factor(group_init) # grouping factor 1- convert to factor
block<-as.factor(group_block) # grouping factor 2- convert to factor
time<-as.factor(group_time)

#### rda model analysis & results #### 
trt_tot_2<-rda(ass.rel.t012 ~ ., data = blocksum[,c(91:94,96)]) # run model using standardized data 
# summary(trt_tot_2)
anova.cca(trt_tot_2, step=1000, by="term") ## test for model significance

# Plotting rda
perc <- round(100*(summary(trt_tot_2)$cont$importance[2, 1:2]), 1)
sc_bp <- vegan::scores(trt_tot_2, display="bp", choices=c(1, 2), scaling=1)
sc_sp <-vegan::scores(trt_tot_2, display="species", choices=c(1,2), scaling=1)
# site
sc_si <- vegan::scores(trt_tot_2, display="sites", choices=c(1,2), scaling=1)
sc_si<-as.data.frame(sc_si) # extract scores
sc_si$site<-rownames(vegan::scores(trt_tot_2)$sites) # extract names 
sc_si$treatment<-group_init # grouping factor 1 
sc_si$block<-group_block # grouping factor 2 
sc_si$treatment <- as.factor(sc_si$treatment)

plot(trt_tot_2,
     scaling = 1, # set scaling type 
     type = "none", # this excludes the plotting of any points from the results
     frame = FALSE,
     # set axis limits
     xlim = c(-.3,.3), 
     ylim = c(-.5,.5),
     # label the plot (title, and axes)
     main = "Triplot RDA - scaling 1",
     xlab = paste0("RDA1 (", perc[1], "%)"), 
     ylab = paste0("RDA2 (", perc[2], "%)") 
) 
text(sc_sp, # adjust text coordinates to avoid overlap with points 
     labels = rownames(sc_sp), 
     col = "grey40", 
     font = 2, # bold
     cex = 0.6)

points (sc_si, col = sc_si$treatment[c("#63A088","#56638A")], pch = 21 , cex=2, bg=c("#63A088","#56638A"))

text(sc_si, # adjust text coordinates to avoid overlap with points 
     labels = sc_si$block, 
     col = "white", 
     font = 2, # bold
     cex = 0.6)

legend("topleft",  legend=c("log", "open"),
       col=c("#63A088","#56638A") ,pch=21, cex=0.8, inset = 0.01, box.lty=1)
# add arrows for effects of the expanatory variables
arrows(0,0, # start them from (0,0)
       sc_bp[,1], sc_bp[,2], # end them at the score value
       col = "black", 
       lwd = 2)
# add text labels for arrows
text(x = sc_bp[,1] +0.05, # adjust text coordinate to avoid overlap with arrow tip
     y = sc_bp[,2] , 
     labels = rownames(sc_bp), 
     col = "black", 
     cex = 1, 
     font = 2)

# can model using varpart to look at contributions of initial treatment and block
# var.mod2<-varpart(ass.rel.t012, init, block, time) # run model on standardized data
# plot(var.mod2, bg=c("hotpink","skyblue","lightyellow"))
# mtext("X1= Treatment; X2=Block; X3=time", side=3)

## can test for significance of contribution of the fraction of initial treatment
# do this with partial redundancy analysis
# trt_Frac<-rda(ass.rel.t012~ init +Condition(block + time)) # partial rda model
# summary(trt_Frac) 
# RsquareAdj(trt_Frac)$adj.r.squared #explanatory power
# anova.cca(trt_Frac) ## this tells us if first condition, init, significantly contributes to overall variance explanation. 

### extracting species scores and plotting 
# species scores
species.scores<-as.data.frame(vegan::scores(ass.rel.t012_NMS,"species")) ## some species don't have scores
species.scores$species<-rownames(species.scores) 

### NMDS 1 and 2 
log<-mds_scores_t012[mds_scores_t012$treatment == "log", ][chull(mds_scores_t012[mds_scores_t012$treatment == 
                                                          "log", c("NMDS1", "NMDS2")]), ]

open<-mds_scores_t012[mds_scores_t012$treatment == "open", ][chull(mds_scores_t012[mds_scores_t012$treatment == 
                                                               "open", c("NMDS1", "NMDS2")]), ]

hulldat<-rbind(log,open)

options(ggrepel.max.overlaps = Inf)

nmds.plot.sp <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_text_repel(data=species.scores, aes(NMDS1, NMDS2, label=species), alpha=0.9, size=5, col='darkgray', na.rm=TRUE)+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment), alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t012, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  labs(title=paste0("Stress: ", round(ass.rel.t012_NMS$stress,3)))

nmds.plot.nutrient <- ggplot()+
  theme_bw()+
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank(), 
        axis.text = element_text(size = 15),
        axis.title=element_text(size=20),
        legend.title=element_text(size=20), 
        legend.text=element_text(size=15))+
  geom_polygon(data=hulldat, aes(NMDS1, NMDS2, fill=treatment, group=treatment),alpha=0.3)+scale_fill_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_point(data=mds_scores_t012, aes(NMDS1, NMDS2, shape=block, col=treatment), size=6)+ scale_shape_manual(values = c(14,15,16,17,11,18,8), name='Block')+
  scale_colour_manual(values=c("#63A088","#56638A"), name="Treatment")+
  geom_segment(aes(x = 0, y = 0, xend = NMDS1, yend = NMDS2), 
       data = en_coord_cont, size =0.5, alpha = 0.5, colour = "grey30") +
     geom_text(data = en_coord_cont, aes(x = NMDS1, y = NMDS2), colour = "grey30", 
       fontface = "bold", label = row.names(en_coord_cont))+
  labs(title=paste0("Stress: ", round(ass.rel.t012_NMS$stress,3)))
  
(nmds.plot.sp + theme(legend.position = "none")) + nmds.plot.nutrient + plot_layout(guides = "collect") + plot_annotation(title = 'Plant composition: 2020')
```

#### *Interpretation* 


### **Q3 Are/how are plant species performances affected by proximity to fallen logs?**<br>
#### *Overview of results* <br> 

**2021** 

There are three response variables: presence (binomial), count (truncated poisson), and per capita biomass (gaussian).

*Presence*

- The best fit model for presence is a tie between between physical barrier and the additive model of physical barrier + nutrient island (deltaAIC=0.32). I present the model analysis of the additive model. 
- Both TRCY and TROR are significantly more likely to be present where there is a physical barrier as compared to in the open (TRCY: p=0.03, TROR: p=0.01) 
- Nutrient island does not significantly explain variation in presence/absence in any species. However, there is a trend across all species that they are more likely present in log-legacy plots. 

*Count* 

- The best fit model for count is nutrient island. 
- Nutrient island does not strongly significantly explain variation in presence/absence in any species. However, TRCY is marginally significantly affected by nutrient island, where there are more TRCY in plots where there is a `log legacy' (there had been a decomposing log in the plot before the experiment began)

*Biomass*

- The best fit model for per capita biomass is the nutrient island, then physical barrier island, then the additive model. They are all within 2 AICc points of each other (deltaAIC=1.55 and 1.76, respectively). I present the model analysis of the additive model.
- Nutrient island significantly explains variation GORO biomass, where there are larger GORO plants in plots where there is a `log legacy' (p=0.03).
- Physical barrier does not explain variation in biomass for any species. 

**2022**

There are again three response variables: presence (binomial), count (truncated poisson), and per capita biomass (gaussian).

*Presence*

1. The best fit model for presence is a tie between between physical barrier and the additive model of physical barrier + nutrient island (deltaAIC=0.24). I present the model analysis of the additive model. 

2. Both TRCY and TROR are significantly more likely to be present where there is a physical barrier as compared to in the open (TRCY: p=0.007, TROR: p=0.03) 

3. Nutrient island significantly explains the presence/absence of TRCY, where TRCY is more likely to be present in log legacy plots as compared to open legacy plots (p=0.02) 

*Count* 

1. The best fit model for count is a tie between nutrient island and physical barrier. I present the model analysis of the nutrient island model. 

2. Nutrient island does not strongly significantly explain variation in presence/absence in any species. 

*Biomass*

1. The best fit model for per capita biomass is the nutrient island, then the additive model, then the physical barrier model. They are all within 1 AICc points of each other (deltaAIC=0.31 and 0.46, respectively). I present the model analysis of the additive model.

2. Nutrient island significantly explains variation in TROR biomass, where log legacy plots have larger TROR as compared to open legacy plots (p=0.04)

3. Physical barrier significantly explains variation in TROR biomass, where plots in the open have larger TROR than plots near a physical barrier (either log or PVC pipe) (p=0.02)


#### *Statistical Methods* <br>
The basic approach is to analyse count and biomass data from 2021 and 2022 sowing experiment. We sowed 15 seeds for each species into 16 plots in each of the seven blocks. There are 6 plot type treatments. The gap and open treatments each have four replicates per block, and the insitu_log, insitu_pvc, open_with_log, and open_with_pvc each have two replicates per block. *note: For each treatment of plot type, there is also a dispersal treatment, but I do not analyse that here (yet).*
<br> 
- For **count data** I use a glmmTMB to run a generalized linear mixed effects model approach to analyse the data. The hurdle model approach I am using is to first code presence/absence as 0 or 1 (1 being any nonzero count value) and run this analysis as a binomial regression. Depending on the model fit and residual dispersion (using DHARMa), I then either run a truncated poisson or truncated negative binomial regression on the count data. Though I did run alternative versions of hurdle models that predict count while accounting for zero inflation, I felt that analyzing the presence/absence, and then analyzing count, may be revealing more of the biology of the system, where presence/absence was distinctly affected by treatments while count was less so.
<br>
- For **biomass data** I use linear mixed effects model to analyse the per capita biomass data. I first do a log(1+n) transformation on the per capita biomass, then analyze. I chose to do per capita biomass because of recalcitrant (!!) residual dispersion in total biomass, even after attemtps at log and square root transformations.
<br>
I chose to do a model selection approach, which I'm trying to move away from generally. However, the models I use to analyze the data represent different hypotheses about *why* plant species might perform differently, and so I chose to do a model comparison and selection approach as a way to not only understand how plant species performance is affected by proximity to fallen logs, but also gain insight as to why this may be the case. 

N.B.:Model comparison might not be the approach we want, and we may want to run the analysis differently. I'm open to discussion and change on this point. 

After model comparison, I use estimated marginal means (package emmeans) on the best fit model and compute the significance of the difference in estimates.

The models I use test the hypotheses from above: Log decomposition creates islands of fertility directly around the fallen log and fallen logs alter the microclimate directly around them by providing shade. 


#### *Analysis*<br>

##### **2021**
```{r 2021 growth, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=TRUE}

### doing vital rate analysis

# packages 
require(lme4)
require(emmeans)
require(pscl)
require(glmmTMB)
require(tidyr)
require(DHARMa)
require(ggplot2)
require(AICcmodavg)
require(ggpubr)

############## 2021 data #############

# read csv
dat<-read.csv('nplants_data_2021_git.csv', header=T)
dat1<-dat[which(dat$seeding_trt==1),]
dat1$physical_barrier<-as.factor(dat1$physical_barrier)
dat1$block<-as.factor(dat1$block)

############# treatment response: do analysis for count by species ############# 

dat2<-(dat1[c(1:4,7,11,15,22)]) # these are block, transect, initial, current_plot_type, ngoro, ntrcy, ntror, physical_barrier
head(dat2) 
countdat<-as.data.frame(dat2 %>% pivot_longer(c(ntror, ngoro, ntrcy)))
countdat$value<-as.numeric(ifelse(countdat$value>15, 15, countdat$value))
countmod<-glmmTMB(value~name*current_plot_type+(1|block), family="poisson", data=countdat)

# test for fit and zero inflation
 sim<-simulateResiduals(countmod)
 testZeroInflation(sim) # zero-inflated so need something else 
 plot(sim)

## going to do a hurdle model, which assumes a zero is only generated in one way 
# https://jsdajournal.springeropen.com/articles/10.1186/s40488-021-00121-4
# #https://stats.stackexchange.com/questions/81457/what-is-the-difference-between-zero-inflated-and-hurdle-models

# hurdle model 
# using examples as presented here: https://www.biorxiv.org/content/biorxiv/suppl/2017/05/01/132753.DC1/132753-2.pdf 
fit3<-glmmTMB(value~name*current_plot_type+(1|block), ziformula=~., family=nbinom2(), data=countdat)
 sim3<-simulateResiduals(fit3)
 plot(sim3)
 testDispersion(sim3) # looks nice ! 
 testZeroInflation(sim3) # looks nice ! 

summary(fit3)
emmip(fit3,~current_plot_type|name, type='response',CI=T)

# visualize
est<-emmeans(fit3,~current_plot_type|name, type='response')
pairs(est)

#### now i'll do a by-hand hurdle model on my own using a truncated negative binomial

### zeros and ones 
countdat$presence<-ifelse(countdat$value==0, 0, 1)
zerofit<-glmmTMB(presence~name*current_plot_type+(1 | block), family=binomial, data=countdat, REML=FALSE)
emmip(zerofit,~current_plot_type|name, type='response',CI=T)
est<-emmeans(zerofit, ~current_plot_type|name, type='response')
pairs(est)

### abundance with a truncated negbinom 
countdat$posicounts<-as.numeric(ifelse(countdat$value==0, "NA", countdat$value))
countfit<-glmmTMB(posicounts~name*current_plot_type+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)
emmip(countfit,~current_plot_type|name, type='response',CI=T)
est<-emmeans(countfit, ~current_plot_type|name, type='response')
pairs(est)

############# treatment response: do analysis for total biomass by species #############

dat3<-(dat1[c(1:4,10,14,18,22)])
totwtdat<-as.data.frame(dat3 %>% pivot_longer(c(wt_max15_goro, wt_max15_tror, wt_max15_trcy)))
totwtdat$log_wt<-log(totwtdat$value) # log transform the weight data to get it normal looking

# model
totwtmod<-lmer(log_wt~name*current_plot_type+(1|block), data=totwtdat, REML=FALSE)

# test for fit, looks pretty good
sim<-simulateResiduals(totwtmod)
plot(sim)

# model summary
summary(totwtmod)
emmip(totwtmod,~current_plot_type|name, CI=T)

est<-emmeans(totwtmod,~current_plot_type|name, type='response')
pairs(est)

############# treatment response: do analysis for per capita biomass by species #############

dat4<-(dat1[c(1:4,9,13,17,22)])
pcwtdat<-as.data.frame(dat4 %>% pivot_longer(c(wt_percapita_goro, wt_percapita_tror, wt_percapita_trcy)))
pcwtdat$log_wt<-log(pcwtdat$value) # log transform the weight data to get it normal looking

# model
pcwtmod<-lmer(log_wt~name*current_plot_type+(1|block), data=pcwtdat, REML=FALSE)

# test for fit, looks pretty good
# sim<-simulateResiduals(pcwtmod)
# plot(sim)

# model summary
summary(pcwtmod)
emmip(pcwtmod,~current_plot_type|name,CI=T)

est<-emmeans(totwtmod,~current_plot_type|name, type='response')
pairs(est)

######### What about the log legacy - initial treatment for 2021 #######

############# log legacy response: do analysis for count by species ############# 
fit3_leg<-glmmTMB(value~name*initial+(1 | block), ziformula=~., family=nbinom2(), data=countdat, REML=FALSE)

## This stuff will just give you the end result counts with the zeros factored in...
summary(fit3_leg)
emmip(fit3_leg,~initial|name, type='response',CI=T)

est<-emmeans(fit3_leg,~initial|name, type='response')
pairs(est)

#### split up occurrence and abundance
### zeros and ones 
zerofit_leg<-glmmTMB(presence~name*initial+(1 | block), family=binomial, data=countdat, REML=FALSE)
emmip(zerofit_leg,~initial|name, type='response',CI=T)
est<-emmeans(zerofit_leg, ~initial|name, type='response')
pairs(est)

### abundance with a truncated negbinom 
countfit_leg<-glmmTMB(posicounts~name*initial+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)
emmip(countfit_leg,~initial|name, type='response',CI=T)
est<-emmeans(countfit_leg, ~initial|name, type='response')
pairs(est)


############# log legacy response: do analysis for total weight by species ############# 

# weights
totwtmod_leg<-lmer(log_wt~name*initial+(1|block), data=totwtdat, REML=FALSE)

# model summary
summary(totwtmod_leg)
emmip(totwtmod_leg,~initial|name,CI=T)

est<-emmeans(totwtmod_leg,~initial|name, type='response')
pairs(est)

############# log legacy response: do analysis for per capita weight by species ############# 

# model
pcwtmod_leg<-lmer(log_wt~name*initial+(1|block), data=pcwtdat, REML=FALSE)

# test for fit, looks pretty good
# sim<-simulateResiduals(pcwtmod_leg)
# plot(sim)

# model summary
summary(pcwtmod_leg)
emmip(pcwtmod_leg,~initial|name,CI=T)

est<-emmeans(pcwtmod_leg,~initial|name, type='response')
pairs(est)


######### What about the physical barrier treatment for 2021 #######

############# physical barrier response: do analysis for count by species ############# 
fit3_phys<-glmmTMB(value~name*physical_barrier+(1 | block), ziformula=~., family=nbinom2(), data=countdat, REML=FALSE)

## This stuff will just give you the end result counts with the zeros factored in...
summary(fit3_phys)
emmip(fit3_phys,~physical_barrier|name, type='response',CI=T)

est<-emmeans(fit3_phys,~physical_barrier|name, type='response')
pairs(est)

#### split up occurrence and abundance
### zeros and ones 
zerofit_phys<-glmmTMB(presence~name*physical_barrier+(1 | block), family=binomial, data=countdat, REML=FALSE)
emmip(zerofit_phys,~physical_barrier|name, type='response',CI=T)
est<-emmeans(zerofit_phys, ~physical_barrier|name, type='response')
pairs(est)

### abundance with a truncated negbinom 
countfit_phys<-glmmTMB(posicounts~name*physical_barrier+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)
emmip(countfit_phys,~physical_barrier|name, type='response',CI=T)
est<-emmeans(countfit_phys, ~physical_barrier|name, type='response')
pairs(est)

############# physical barrier response: do analysis for total weight by species ############# 

# weights
totwtmod_phys<-lmer(log_wt~name*physical_barrier+(1|block), data=totwtdat, REML=FALSE)

# model summary
summary(totwtmod_phys)
emmip(totwtmod_phys,~physical_barrier|name,CI=T)

est<-emmeans(totwtmod_phys,~physical_barrier|name, type='response')
pairs(est)

############# physical barrier response: do analysis for per capita weight by species ############# 

# model
pcwtmod_phys<-lmer(log_wt~name*physical_barrier+(1|block), data=pcwtdat, REML=FALSE) 

# test for fit, looks pretty good
# sim<-simulateResiduals(pcwtmod_leg)
# plot(sim)

# model summary
summary(pcwtmod_phys)
emmip(pcwtmod_phys,~physical_barrier|name,CI=T)

est<-emmeans(pcwtmod_phys,~physical_barrier|name, type='response')
pairs(est)

#### What about both physical and legacy? #### 
### zeros and ones 
zerofit_intxn<-glmmTMB(presence~name*physical_barrier*initial+(1 | block), family=binomial, data=countdat, REML=FALSE)

sim<-simulateResiduals(zerofit_intxn)
plot(sim)
testDispersion(sim)
testZeroInflation(sim)

emmip(zerofit_intxn,initial~physical_barrier|name, type='response',CI=T)
est<-emmeans(zerofit_intxn, ~physical_barrier|name|initial, type='response')
pairs(est)

### abundance with a truncated negbinom 
countfit_intxn<-glmmTMB(posicounts~name*physical_barrier*initial+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)

sim<-simulateResiduals(countfit_intxn)
plot(sim)
testDispersion(sim)
testZeroInflation(sim)

emmip(countfit_intxn,~physical_barrier|name|initial, type='response',CI=T)
est<-emmeans(countfit_intxn, ~physical_barrier|name|initial, type='response')
pairs(est)

### additive examp,es
zerofit_add<-glmmTMB(presence~name*physical_barrier+name*initial+(1 | block), family=binomial, data=countdat, REML=FALSE)

countfit_add<-glmmTMB(posicounts~name*physical_barrier+name*initial+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)

### per capita biomass 

# model - intxn
pcwtmod_intxn<-lmer(log_wt~name*physical_barrier*initial+(1|block), data=pcwtdat, REML=FALSE)

# model - no intxn
pcwtmod_add<-lmer(log_wt~name*physical_barrier+name*initial+(1|block), data=pcwtdat, REML=FALSE)

```

```{r 2021 model comp, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE}
#### 2021 model comparison for counts #### 
## zeros 
zero_candmods<-list("Plot type"=zerofit, 
                    "Physical barrier"=zerofit_phys,
                    "Nutrient island"=zerofit_leg,
                    "Physical Barrier + Nutrient Island"=zerofit_add,
                    "Physical Barrier x Nutrient Island"=zerofit_intxn)
aictab(zero_candmods) 
#summary(zerofit_add)
pairs(emmeans(zerofit_add, ~initial|name))
pairs(emmeans(zerofit_add, ~physical_barrier|name))
# best fit model is a tie between physical barrier and additive model (deltaAIC=0.32)
# i will show results from additive model. 

# counts
count_candmods<-list("Plot type"=countfit, 
                     "Physical barrier"=countfit_phys,
                     "Nutrient island"=countfit_leg,
                     "Physical Barrier + Nutrient Island"=countfit_add,
                     "Physical Barrier x Nutrient Island"=countfit_intxn)
aictab(count_candmods) 
#summary(countfit_leg)
pairs(emmeans(countfit_leg, ~initial|name))
# best fit model is nutrient island (next best deltaAIC=2.41 and it's physical barrier.)
# I will show the results for nutrient island. 


#### 2021 model comparison for per capita biomass #### 
pcwt_candmods<-list("Plot type"=pcwtmod, 
                    "Physical barrier"=pcwtmod_phys,
                    "Nutrient island"=pcwtmod_leg,
                    "Physical Barrier + Nutrient Island" = pcwtmod_add,
                    "Physical Barrier x Nutrient Island"=pcwtmod_intxn)
aictab(pcwt_candmods) 
#summary(pcwtmod_add)
pairs(emmeans(pcwtmod_add, ~physical_barrier|name))
pairs(emmeans(pcwtmod_add, ~initial|name))
# best fit model is physical barrier by a hair, then nutrient island, then additive model. They are all within striking distance. 
# deltaAIC physical barrier - nutrient island = 1.55
# deltaAIC physical - nutrient island = 1.76
# I will show the results for addivive model. 
```

```{r 2021 figcode, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=TRUE}

### figures ###
# best fit models - zeros 
# colors
mimiscols<-c("#D66972","#108780")
# zerofit_add<-glmmTMB(presence~name*physical_barrier+name*initial+(1 | block), family=binomial, data=countdat, REML=FALSE)

zfit_est<-as.data.frame(emmeans(zerofit_add,~initial|physical_barrier|name, type='response'))
zfit_est$name<-c(rep("ngoro", 4), rep("ntrcy",4), rep("ntror",4))

pl1<-ggplot(zfit_est,aes(physical_barrier, prob,group=initial),)+
  scale_color_manual(values=mimiscols)+
  geom_point(aes(col=initial), size=2, position=position_dodge(width=0.5))+
  geom_linerange(aes(ymin=asymp.LCL, ymax=asymp.UCL, col=initial), position=position_dodge(width=0.5))+
#  geom_line(aes(col=initial), position=position_dodge(width=0.5))+
 facet_wrap(vars(name), labeller=labeller(name=
                                             c("ngoro"="GORO",
                                               "ntrcy"="TRCY",
                                               "ntror"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15),
        legend.position="top")+
  xlab("Physical Barrier")+
  ylab("Occurrence")+
  geom_jitter(data=countdat,
             aes(x=physical_barrier, y=presence, color=initial), 
             height=0.1,
             alpha=0.5)+
  labs(color = "Initial Plot Type")
  
# best fit model - counts 
# countfit_leg<-glmmTMB(posicounts~name*initial+(1 | block), family=truncated_nbinom2(), data=countdat, REML=FALSE)

cfit_est<-as.data.frame(emmeans(countfit_leg,~initial|name, type='response'))
cfit_est$name<-c(rep("ngoro", 2), rep("ntrcy", 2), rep("ntror",2))

pl2<-ggplot(cfit_est,aes(initial, response, group=1))+
  geom_jitter(data=countdat,
              aes(x=initial, y=posicounts),
              width=0.1,
              alpha=0.4,
              color="gray")+
  geom_point(size=2, color="black")+
  geom_linerange(aes(ymin=asymp.LCL, ymax=asymp.UCL),color="black")+
#  geom_line(color="black")+
facet_wrap(vars(name), labeller=labeller(name=
                                             c("ngoro"="GORO",
                                               "ntrcy"="TRCY",
                                               "ntror"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15))+
  xlab("Initial Plot Type")+
  ylab("Abundance")+
  labs(color = "Initial Plot \n Type")

# best fit model - pcbiomass
# pcwtmod_phys<-lmer(log_wt~name*physical_barrier+(1|block), data=pcwtdat, REML=FALSE)

pcbfit_est<-as.data.frame(emmeans(pcwtmod_add,~physical_barrier|name|initial, type='response'))


pl3<-ggplot(pcbfit_est,aes(physical_barrier, emmean, group=initial))+
  scale_color_manual(values=mimiscols)+
  geom_linerange(aes(ymin=lower.CL, ymax=upper.CL, col=initial), position=position_dodge(width=0.5))+
#  geom_line(aes(col=initial), position=position_dodge(width=0.5))+
  facet_wrap(vars(name), labeller=labeller(name=
                                             c("wt_percapita_goro"="GORO",
                                               "wt_percapita_trcy"="TRCY",
                                               "wt_percapita_tror"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15),
        legend.position="top")+
  xlab("Physical Barrier")+
  ylab("log(Biomass)")+
  geom_jitter(data=pcwtdat,
              aes(x=physical_barrier, y=log_wt, color=initial), 
              height=0.1,
              width=0.2,
              alpha=0.5)+
  geom_point(aes(col=initial), size=2, position=position_dodge(width=0.5))+
  labs(color = "Initial Plot Type")
# pl3
### altogether now
```

```{r 2021 figure plot, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE, fig.width =6, fig.height=12}
ggarrange(pl1, pl2, pl3, ncol=1, common.legend = T)
```



##### **2022**
```{r 2022 growth, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=TRUE}
# packages 
require(lme4)
require(emmeans)
require(pscl)
require(glmmTMB)
require(tidyr)
require(DHARMa)
require(ggplot2)
require(AICcmodavg)
require(ggpubr)

############## 2022 data ##############

# read csv
dat<-read.csv('nplants_data_2022.csv', header=T)
dat1<-dat[which(dat$seeding_trt==1),]
dat1$physical_barrier<-as.factor(dat1$physical_barrier)
dat1$block<-as.factor(dat1$block)
names(dat1)

# subset
dat2<-dat1[,c(1,2:4,26:28,19)] # these are block, transect, initial, current_plot_type, ngoro_plants, ntrcy_plants, ntror_plants, physical_barrier
head(dat2)

## because of the way weeding worked, where we thinned only once and probably too early in the season, there were cases where plants came up, we thinned them, and then when we collected plants at the end of the growing season there were more that popped up. 
# I am choosing to use the total number of a species that popped up in the zone of planting. this required a somewhat complex excel formula that did not double-count the one individual when summing the total, and also accounts for the plants that came up but
# did not survive. This value is called 'tot' (e.g. ngoro_tot). 
# It's impossible to get the same dataset as the one from 2021 because we planted the plants and only came back when it was time to collect at the end of the season, thus capturing both survival through the season and germination. 
# to get the total in the "tot" columns, I wrote a formula in excel, written below
# total = if((t0+t2=0),0,if(t0=0,t2,if(t2=0,t0, if(t0+t2=1,1,(t0-1+t2)))))
# in this expression t0 is the germ value (e.g. ngoro_germ) and t2 is the plants value (e.g. ngoro_plants). 
# I can run the analysis with germ, plants, or tot. I'm choosing to do the analysis on tot, but we can revisit this choice if we feel there's a better way to comparably (or not) analyze the data between 2021 and 2023. 
 
# pivot
dat22<-as.data.frame(dat2 %>% pivot_longer(c(ntrcy_tot, ngoro_tot, ntror_tot)))
range(dat22$value)
dat22$value>15 # one sample is larger than 15, it is a tror.

# max out at 15 
dat22$value<-as.numeric(ifelse(dat22$value>15, 15, dat22$value))



#################################### TREATMENT RESPONSE PRELIM ANALYSIS ####################################
############# treatment response: do analysis for count by species ############# 

# I am going to do the analysis as in 2021 now, with final counts and biomass. 
countmod<-glmmTMB(value~name*current_plot_type+(1|block), family="poisson", data=dat22)

# test for fit and zero inflation
sim<-simulateResiduals(countmod)
testZeroInflation(sim) # zero-inflated so need something else! 
plot(sim) 

## going to do a hurdle model, which assumes a zero is only generated in one way 
# https://jsdajournal.springeropen.com/articles/10.1186/s40488-021-00121-4
# #https://stats.stackexchange.com/questions/81457/what-is-the-difference-between-zero-inflated-and-hurdle-models

# hurdle model 
# using examples as presented here: https://www.biorxiv.org/content/biorxiv/suppl/2017/05/01/132753.DC1/132753-2.pdf 
fit3<-glmmTMB(value~name+current_plot_type+(1|block), ziformula=~., family=nbinom2(), data=dat22) # model has non-positive definite hessian matrix when the model expression contains an interaction, so made it additive.
 sim3<-simulateResiduals(fit3)
 plot(sim3)
 testDispersion(sim3) # looks ok ! 
 testZeroInflation(sim3) # looks ok ! 

summary(fit3)
emmip(fit3,~current_plot_type|name, type='response',CI=T)

# visualize
est<-emmeans(fit3,~current_plot_type|name, type='response')
pairs(est)

#### now i'll do a by-hand hurdle model on my own using a truncated negative binomial

### zeros and ones 

dat22$presence<-ifelse(dat22$value==0, 0, 1)
zerofit<-glmmTMB(presence~name*current_plot_type+(1 | block), family=binomial, data=dat22, REML=FALSE)
emmip(zerofit,~current_plot_type|name, type='response',CI=T)
est<-emmeans(zerofit, ~current_plot_type|name, type='response')
pairs(est)
# no significant differences

### abundance with a truncated negbinom 
dat22$posicounts<-as.numeric(ifelse(dat22$value==0, "NA", dat22$value))
countfit<-glmmTMB(posicounts~name*current_plot_type+(1 | block), family=truncated_nbinom2(), data=dat22, REML=FALSE)
emmip(countfit,~current_plot_type|name, type='response',CI=T)
est<-emmeans(countfit, ~current_plot_type|name, type='response')
pairs(est)
# no significant differences in abundance

############# treatment response: do analysis for total biomass by species #############


dat3<-(dat1[c(1:4,19,21,23,25)])
totwtdat<-as.data.frame(dat3 %>% pivot_longer(c(wt_max15_goro, wt_max15_tror, wt_max15_trcy)))
totwtdat$log_wt<-log1p(totwtdat$value) # log transformation does not help the insane amount of heteroscedasticity here, neither does a square root transformation.

# model
totwtmod<-lm(log_wt~name*current_plot_type, data=totwtdat) # fit is singular when including a random effect for block so not doing that

# test for fit
sim<-simulateResiduals(totwtmod) # insanely heteroscedastic, doesn't get better with sqrt transform (all transformations make it worse)
plot(sim)

# model summary - don't trust this the residual dispersion is fucked, commenting out.
# summary(totwtmod)
# emmip(totwtmod,~current_plot_type|name, CI=T)
# 
# est<-emmeans(totwtmod,~current_plot_type|name, type='response')
# pairs(est)

############# treatment response: do analysis for per capita biomass by species #############

# per capita might help with heteroscedasticity  
dat4<-(dat1[c(1:4,19,20,22,24)])
pcwtdat<-as.data.frame(dat4 %>% pivot_longer(c(wt_percapita_goro, wt_percapita_tror, wt_percapita_trcy)))
pcwtdat$log_wt<-log(pcwtdat$value) # log transform the weight data to get it normal looking - it is heteroscedastic otherwise

# model
pcwtmod<-lm(log_wt~name*current_plot_type, data=pcwtdat) # fit is singular with random effect.

# test for fit, looks pretty good
sim<-simulateResiduals(pcwtmod)
plot(sim) ## much better! 

# model summary
summary(pcwtmod)
emmip(pcwtmod,~current_plot_type|name,CI=T)

est<-emmeans(totwtmod,~current_plot_type|name, type='response')
pairs(est)
est2<-emmeans(totwtmod,~name, type='response')
pairs(est)
# not any differences in per capita biomass among treatments within species, but goro is larger than the other two

#################################### PHYSICAL BARRIER ANALYSIS ####################################

######### What about the physical barrier - initial treatment for 2022 #######

# this is a model where do zero inflation and count together (occurrence and abundance)
fit_phys<-glmmTMB(value~name*physical_barrier+(1 | block), ziformula=~., family=nbinom2(), data=dat22, REML=F) #
sim<-simulateResiduals(fit_phys)
plot(sim)
testDispersion(sim) 
testZeroInflation(sim)

summary(fit_phys)
emmip(fit_phys, ~physical_barrier|name, type='response', CI=T)
est<-emmeans(fit_phys,~physical_barrier|name, type='response')
pairs(est)
# no significant differences in total plants (occurrence and abundance) 

# split up occurrence and abundance
### zeros and ones 
zerofit_phys<-glmmTMB(presence~name*physical_barrier+(1 | block), family=binomial, data=dat22, REML=F)

sim<-simulateResiduals(zerofit_phys)
plot(sim)
testDispersion(sim) # looks good
testZeroInflation(sim) # looks good

summary(zerofit_phys)
emmip(zerofit_phys,~physical_barrier|name, type='response',CI=T)
est<-emmeans(zerofit_phys, ~physical_barrier|name, type='response')
pairs(est)

# physical barrier occurrence results
# physical barrier level does not significantly explain variation in goro 
# trcy and tror probability of occurrence are higher in places where there is a physical barrier (p=0.02 and p=0.009 respectively)

### abundance with a truncated negbinom 
countfit_phys<-glmmTMB(posicounts~name*physical_barrier+(1 | block), family=truncated_nbinom2(), data=dat22, REML=F)

sim<-simulateResiduals(countfit_phys)
plot(sim)
testDispersion(sim)
testZeroInflation(sim)

summary(countfit_phys)
emmip(countfit_phys,~physical_barrier|name, type='response',CI=T)
est<-emmeans(countfit_phys, ~physical_barrier|name, type='response')
pairs(est)
# abundance does not differ between physical barrier treatments for any of the plant species


# model
# pcwtmod_phys<-lmer(log_wt~name*physical_barrier+(1|block), data=pcwtdat, REML=FALSE) # singular 
pcwtmod_phys<-lm(log_wt~name*physical_barrier, data=pcwtdat) 


# test for fit, looks pretty good
 sim<-simulateResiduals(pcwtmod_phys)
 plot(sim)

# model summary
summary(pcwtmod_phys)
emmip(pcwtmod_phys,~physical_barrier|name,CI=T)

est<-emmeans(pcwtmod_phys,~physical_barrier|name, type='response')
pairs(est)

#################################### LEGACY ANALYSIS ####################################

############# log legacy response: do analysis for count by species ############# 
# fit3_leg<-glmmTMB(value~name*initial+(1 | block), ziformula=~., family=nbinom2(), data=dat22, REML=FALSE) # does not converge, i think it's poisson dist.
fit3_leg<-glmmTMB(value~name*initial+(1 | block), ziformula=~., family=poisson(), data=dat22, REML=FALSE) 

## This stuff will just give you the end result counts with the zeros factored in...
summary(fit3_leg)
emmip(fit3_leg,~initial|name, type='response',CI=T)

est<-emmeans(fit3_leg,~initial|name, type='response')
pairs(est)

#### split up occurrence and abundance
### zeros and ones 
zerofit_leg<-glmmTMB(presence~name*initial+(1 | block), family=binomial, data=dat22, REML=FALSE)
emmip(zerofit_leg,~initial|name, type='response',CI=T)
est<-emmeans(zerofit_leg, ~initial|name, type='response')
pairs(est)

# probability of occurrence is lower for trcy in places where initial treatment is open (higher where there is a log legacy p=0.03)

### abundance with a truncated negbinom 
countfit_leg<-glmmTMB(posicounts~name*initial+(1 | block), family=truncated_nbinom2(), data=dat22, REML=FALSE)
emmip(countfit_leg,~initial|name, type='response',CI=T)
est<-emmeans(countfit_leg, ~initial|name, type='response')
pairs(est)


# model for per capita weight
# pcwtmod_leg<-lmer(log_wt~name*initial+(1|block), data=pcwtdat, REML=FALSE) #singular
pcwtmod_leg<-lm(log_wt~name*initial, data=pcwtdat)

# test for fit, looks pretty good
# sim<-simulateResiduals(pcwtmod_leg)
# plot(sim)

# model summary
summary(pcwtmod_leg)
emmip(pcwtmod_leg,~initial|name,CI=T)

est<-emmeans(pcwtmod_leg,~initial|name, type='response')
pairs(est)

# biomass per capita in tror is lower in open legacy environments (p=0.03); biomass per capita in trcy is higher in open legacy environments

#################################### PHYSICAL BARRIER X LEGACY ANALYSIS ####################################
######### What about both physical and legacy? ######### 

#### interaction model
### zeros and ones 
zerofit_intxn<-glmmTMB(presence~name*physical_barrier*initial+(1 | block), family=binomial, data=dat22, REML=F)

sim<-simulateResiduals(zerofit_intxn)
plot(sim)
testDispersion(sim)
testZeroInflation(sim)

emmip(zerofit_intxn,initial~physical_barrier|name, type='response',CI=T)
est<-emmeans(zerofit_intxn, ~physical_barrier|name|initial, type='response')
pairs(est)

# goro presence/absence not explained by physical barrier or initial treatment 
# when the initial treatment is "open", trcy has higher prbability of occurring when there is a physical barrier. the same goes for tror.
# if there is a legacy of a log, then there is no significant difference between physical barrier treatments for tror or for trcy. 

### abundance with a truncated negbinom 
countfit_intxn<-glmmTMB(posicounts~name*physical_barrier*initial+(1 | block), family=truncated_nbinom2(), data=dat22, REML=F)

sim<-simulateResiduals(countfit_intxn)
plot(sim)
testDispersion(sim)
testZeroInflation(sim)

emmip(countfit_intxn,~physical_barrier|name|initial, type='response',CI=T)
est<-emmeans(countfit_intxn, ~physical_barrier|name|initial, type='response')
pairs(est)

# abundance not explained by physical barrier or initial treatment for all three species

#### additive model 
zerofit_add<-glmmTMB(presence~name*physical_barrier+name*initial+(1 | block), family=binomial, data=dat22, REML=F)
summary(zerofit_add)

countfit_add<-glmmTMB(posicounts~name*physical_barrier+name*initial+(1 | block), family=truncated_nbinom2(), data=dat22, REML=F)
summary(countfit_add)

### per capita biomass 

# model - intxn
# pcwtmod_intxn<-lmer(log_wt~name*physical_barrier*initial+(1|block), data=pcwtdat, REML=FALSE) # singular
pcwtmod_intxn<-lm(log_wt~name*physical_barrier*initial, data=pcwtdat)

# model - no intxn
# pcwtmod_add<-lmer(log_wt~name*physical_barrier+name*initial+(1|block), data=pcwtdat, REML=FALSE) # singular 
 pcwtmod_add<-lm(log_wt~name*physical_barrier+name*initial, data=pcwtdat) 
summary(pcwtmod_add)

emmip(pcwtmod_add,~physical_barrier|name|initial, type='response',CI=T)
est<-emmeans(pcwtmod_add, ~initial|name, type='response')
pairs(est)
```

```{r 2022 model comp, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE}
##### 2022 candidate model comparison ##### 

## zeros 
zero_candmods<-list("Plot type"=zerofit, 
                    "Physical barrier"=zerofit_phys,
                    "Nutrient island"=zerofit_leg,
                    "Physical Barrier + Nutrient Island"=zerofit_add,
                    "Physical Barrier x Nutrient Island"=zerofit_intxn)
aictab(zero_candmods)
#summary(zerofit_add)
pairs(emmeans(zerofit_add, ~initial|name))
pairs(emmeans(zerofit_add, ~physical_barrier|name))


# best fit model is a tie between physical barrier and physical barrier + nutrient island
# i will show the results for physical barrier + nutrient island. 

# counts
count_candmods<-list("Plot type"=countfit, 
                     "Physical barrier"=countfit_phys,
                     "Nutrient island"=countfit_leg,
                     "Physical Barrier + Nutrient Island"=countfit_add,
                     "Physical Barrier x Nutrient Island"=countfit_intxn)
aictab(count_candmods)
#summary(countfit_leg)
pairs(emmeans(countfit_leg, ~initial|name))


# best fit model is nutrient island, tied with physical barrier. 
# i will show the results for nutrient island.

pcwt_candmods<-list("Plot type"=pcwtmod, 
                    "Physical barrier"=pcwtmod_phys,
                    "Nutrient island"=pcwtmod_leg,
                    "Physical Barrier + Nutrient Island" = pcwtmod_add,
                    "Physical Barrier x Nutrient Island"=pcwtmod_intxn)
aictab(pcwt_candmods)
#summary(pcwtmod_add)
pairs(emmeans(pcwtmod_add, ~physical_barrier|name))
pairs(emmeans(pcwtmod_add, ~initial|name))
# best fit model is nutrient island, tied with physical barrier + nutrient island, and then physical barrier.
# i will show the results for the additive model. 

# tror is bigger when the legacy of the log and the log is still present
```

```{r 2022 plot results, message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results=TRUE}

### figures ###
# best fit models - zeros 
# colors
mimiscols<-c("#D66972","#108780")
zerofit_add<-glmmTMB(presence~name*physical_barrier+name*initial+(1 | block), family=binomial, data=dat22, REML=FALSE)

zfit_est<-as.data.frame(emmeans(zerofit_add,~initial|physical_barrier|name, type='response'))

#facet_wrap(vars(time), labeller = labeller(time = 
#    c("t0" = "2020",
#      "t1" = "2021",
#      "t2" = "2022")))+
  
pl4<-ggplot(zfit_est,aes(physical_barrier,prob,group=initial),)+
  scale_color_manual(values=mimiscols)+
  geom_point(aes(col=initial), size=2, position=position_dodge(width=0.5))+
  geom_linerange(aes(ymin=asymp.LCL, ymax=asymp.UCL, col=initial), position=position_dodge(width=0.5))+
  #geom_line(aes(col=initial), position=position_dodge(width=0.5))+
  facet_wrap(vars(name), labeller=labeller(name=
                                             c("ngoro_tot"="GORO",
                                               "ntrcy_tot"="TRCY",
                                               "ntror_tot"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15),
        legend.position="top")+
  xlab("Physical Barrier")+
  ylab("Occurrence")+
  geom_jitter(data=dat22,
              aes(x=physical_barrier, y=presence, color=initial), 
              height=0.1,
              alpha=0.5)+
  labs(color = "Initial Plot Type")
# pl4
summary(zerofit_add)
pairs(emmeans(zerofit_add, ~physical_barrier|name|initial))

# tror and trcy do better where there is a physical barrier as compared to when there is not (tror p=0.03, trcy p=0.007)

pairs(emmeans(zerofit_add, ~initial|name|physical_barrier))

# trcy does better with log initial as compared to open initial (p=0.03)

 countfit_leg<-glmmTMB(posicounts~name*initial+(1 | block), family=truncated_nbinom2(), data=dat22, REML=FALSE)

cfit_est<-as.data.frame(emmeans(countfit_leg,~initial|name, type='response'))

pl5<-ggplot(cfit_est,aes(initial, response, group=1))+
  geom_jitter(data=dat22,
              aes(x=initial, y=posicounts),
              width=0.1,
              alpha=0.4,
              color="gray")+
  geom_point(size=2, color="black")+
  geom_linerange(aes(ymin=asymp.LCL, ymax=asymp.UCL),color="black")+
 # geom_line(color="black")+
   facet_wrap(vars(name), labeller=labeller(name=
                                             c("ngoro_tot"="GORO",
                                               "ntrcy_tot"="TRCY",
                                               "ntror_tot"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15))+
  xlab("Initial Plot Type")+
  ylab("Abundance")+
  labs(color = "Initial Plot \n Type")
pairs(emmeans(countfit_leg, ~initial|name))

# pl5

pcbfit_est<-as.data.frame(emmeans(pcwtmod_add,~physical_barrier|name|initial, type='response'))


pl6<-ggplot(pcbfit_est,aes(physical_barrier, emmean, group=initial))+
  scale_color_manual(values=mimiscols)+
  geom_linerange(aes(ymin=lower.CL, ymax=upper.CL, col=initial), position=position_dodge(width=0.5))+
#  geom_line(aes(col=initial), position=position_dodge(width=0.5))+
   facet_wrap(vars(name), labeller=labeller(name=
                                             c("wt_percapita_goro"="GORO",
                                               "wt_percapita_trcy"="TRCY",
                                               "wt_percapita_tror"="TROR")))+
  theme_bw()+
  theme(strip.text.x = element_text(size=10),
        strip.background = element_blank(),
        axis.text=element_text(size=15),
        axis.title=element_text(size=20),
        legend.text=element_text(size=15),
        legend.title=element_text(size=15),
        legend.position="top")+
  xlab("Physical Barrier")+
  ylab("log(Biomass)")+
  geom_jitter(data=pcwtdat,
              aes(x=physical_barrier, y=log_wt, color=initial), 
              height=0.1,
              width=0.2,
              alpha=0.5)+
    geom_point(aes(col=initial), size=2, position=position_dodge(width=0.5))+
  labs(color = "Initial Plot Type")
#pl6
```

```{r 2022 figure, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE, results=TRUE, fig.width =6, fig.height=12}

ggarrange(pl4, pl5, pl6, ncol=1, common.legend = T)

```
